<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>dom-diff</title>
    <link href="/2021/01/13/dom-diff/"/>
    <url>/2021/01/13/dom-diff/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM-Diff"><a href="#DOM-Diff" class="headerlink" title="DOM Diff"></a>DOM Diff</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>服务器v2ray协议学习</title>
    <link href="/2021/01/13/%E6%9C%8D%E5%8A%A1%E5%99%A8v2ray%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/13/%E6%9C%8D%E5%8A%A1%E5%99%A8v2ray%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="v2ray搭建"><a href="#v2ray搭建" class="headerlink" title="v2ray搭建"></a>v2ray搭建</h2><p>&emsp;&emsp;之前看过一些网络协议，在研究的时候就发现有这么个v2ray的工具，可以加密连接，所以拿来研究以下。</p><ol><li>首先你需要买一台服务器/轻量云服务器，哪个便宜买哪个，我自己测试之后，8M的带宽就能完全应付日常使用了，装上Centos系统。</li><li>买好之后ssh连接到服务器上，可以用电脑自带的终端/cmd，或者用别的软件，我用的是Termius，比较方便，输入账号密码之后，进入服务器</li><li>我之前使用的官方自己的代码搭建的，虽然也可以但是不够直观，所以又找到一个比较好的轮子，v2-ui，可以在可视化的操控v2ray的连接情况。只需要在控制台输入<pre><code class="hljs css"><span class="hljs-selector-tag">bash</span> &lt;(<span class="hljs-selector-tag">curl</span> <span class="hljs-selector-tag">-Ls</span> <span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">blog</span><span class="hljs-selector-class">.sprov</span><span class="hljs-selector-class">.xyz</span>/<span class="hljs-selector-tag">v2-ui</span><span class="hljs-selector-class">.sh</span>)</code></pre>一般来说都没问题的，会直接进入下面的环节，然后就是漫长的等待，等待他下完v2-ui-linux，如果网速快不需要的多久，不快的话可能就得20来分钟了.<br>项目地址是<a href="https://github.com/sprov065/v2-ui">v2-ui</a></li></ol><ul><li>PS:如果遇到连接问题，修改etc/hosts，新增一行<pre><code class="hljs accesslog"><span class="hljs-number">199.232.28.133</span> raw.githubusercontent.com</code></pre>大概率可以解决问题的。</li><li>如果输入命令没有显示，需要把<code>-Ls</code>改成<code>-L</code>，这样就把错误暴露出来了，可以直接按照错误去修正</li></ul><ol start="4"><li>全新安装后，在浏览器中打开 http://&lt;服务器IP&gt;:65432 即可访问面板，默认用户名和密码都是 admin，当然你也可以在控制面板中输入v2-ui,按照提示修改端口和重置。</li></ol><p><strong><em>！！！不过请你一定要到服务器的安全设置里，将端口放行，一般在安全配置里面，不放行是进不去网页的</em></strong></p><ol start="5"><li><p>进入网页后的操作就简单多了，直接添加就行，改动端口和传输配置ws或者tcp，可以自行研究</p></li><li><p>另外呢，还可以自己添加bbr加速tcp连接，可以让网速更快，直接在控制台输入这个：</p><pre><code class="hljs css"><span class="hljs-selector-tag">wget</span> <span class="hljs-selector-tag">-N</span> <span class="hljs-selector-tag">--no-check-certificate</span> &quot;<span class="hljs-selector-tag">https</span>://<span class="hljs-selector-tag">raw</span><span class="hljs-selector-class">.githubusercontent</span><span class="hljs-selector-class">.com</span>/<span class="hljs-selector-tag">chiakge</span>/<span class="hljs-selector-tag">Linux-NetSpeed</span>/<span class="hljs-selector-tag">master</span>/<span class="hljs-selector-tag">tcp</span><span class="hljs-selector-class">.sh</span>&quot; &amp;&amp; <span class="hljs-selector-tag">chmod</span> +<span class="hljs-selector-tag">x</span> <span class="hljs-selector-tag">tcp</span><span class="hljs-selector-class">.sh</span> &amp;&amp; ./<span class="hljs-selector-tag">tcp</span><span class="hljs-selector-class">.sh</span></code></pre></li><li><p>运行完之后会出现脚本页面，自己选择安装魔改还是plus，整个流程大致就是先按1或者2 ，然后在按照提示运行完成后，在次进入这个页面输入4或者5或者6，成功之后就会显示开启成功，加速成功啦。</p></li><li><p>服务器最好dd以下系统，给你一个纯净系统<br>综上就是大致的流程了。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>v2ray</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题</title>
    <link href="/2020/12/22/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2020/12/22/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1、Vue中父子组件的加载顺序？<br>&emsp;&emsp;父子组件在加载时</p><ul><li>如果子组件是同步加载的，那么父组件会先created然后在beforemounted时对子组件进行created，子组件根据在父组件中使用的顺序进行created，当所有子组件被mounted时，父组件才会进行mounted。</li><li>如果子组件时懒加载模式，那么父组件会在created，mounted之后的beforeUpdate时根据子组件的顺序进行子组件的created和mounted</li></ul><p>2、浏览器每一帧发生了什么事情？<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201223165207.png"><br>3、页面适配怎么做？rem什么原理？<br>&emsp;&emsp;@media screen可以进行区分，也可以使用viewport进行缩放，或者使用rem根据html根元素的font-size进行缩放，很少使用em，因为em是根据父元素的font-size进行缩放，而且每个组件的em值可能都是不一样很难管理<br>4、贪心和分治说一下？<br>&emsp;&emsp;贪心通俗理解为找到局部最优解，在局部情况下我只找最接近结果的情况，然后所有情况加在一起得到最终最优解，该算法必须一系列子问题中每个子问题不依赖于后面子问题的解，我才能确定当前子问题的局部最优解不会影响最终解；<br>&emsp;&emsp;分治算法也是大问题拆解成小问题注意解决的情况。比较经典的就是快速排序算法，和归并排序，快排是通过找到一个mid值，然后把小于的放左边大于的放右边，然后左右再继续执行相同的操作来进行排序的，这就是把大的排序问题拆解成小的排序问题，直到最后解决了小问题，那么大问题也得到解决。归并中也是类似，把数分成两堆，然后解决小问题的排序问题，最后把小的排序结果进行归并操作得到最终排序结果。<br>5、Vue的生命周期有啥？<br>&emsp;&emsp;有几个重要阶段：beforeCreate，created，beforeMount，mounted，beforeUpdate，updated，beforeDestroy，destroyed，分别是组件创建，组件载入，组件更新，组件销毁，其中数据是在created时就被获得，载入时数据载入Dom<br>6、Webpack你是用什么进行打包优化的？<br>&emsp;&emsp;我用的是hard-sourse-webpack-plugin，因为他第一次要缓存所以第一次时速度没有变化，但是第二次的速度就能特别快，提升很显著，起码在80%以上，选这个是因为这玩意很简单，只需要导入后然后在plugins里加上new HardSourceWebpackPlugin就能实现基本功能，特别简单好用。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Event Loop解读</title>
    <link href="/2020/11/25/browser/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2020/11/25/browser/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="浏览器Event-Loop"><a href="#浏览器Event-Loop" class="headerlink" title="浏览器Event Loop"></a>浏览器Event Loop</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>To coordinate events, user interaction, scripts, rendering, networking, and so forth, user agents must use event loops as described in this section. Each agent has an associated event loop, which is unique to that agent.</p><p>要想了解浏览器的事件机制，我们需要知道，浏览器的线程基本概念</p><h3 id="浏览器进程线程"><a href="#浏览器进程线程" class="headerlink" title="浏览器进程线程"></a>浏览器进程线程</h3><p>浏览器中是多线程多进程的，我们每打开一个新的页面就会打开一个新的进程，每个进程中都会有多个线程在运作，其中常见的线程有以下几种：</p><ol><li>GUI渲染线程</li></ol><ul><li>负责页面渲染，处理HTML，CSS解析，DOM树的构建、布局和绘制；</li><li>当页面发生重绘重排时会重新调用此线程；</li><li>该线程和JS线程互斥，所以当GUI执行时，JS会被挂起，JS线程执行时，GUI会被挂起，直到任务队列空了，才会去执行GUI</li></ul><ol start="2"><li>JS线程</li></ol><ul><li>负责js代码的执行；</li><li>执行准备好的事件；</li></ul><ol start="3"><li>定时器线程</li></ol><ul><li>负责执行定时器任务例如：setTimeout,setInterval；</li><li>主线程执行遇到定时器任务时，将任务加入定时器线程，在计时完毕后，任务会加入任务队列，等待JS线程的执行</li></ul><ol start="4"><li>事件触发线程</li></ol><p>负责将准备好的事件添加到任务队列，等待JS线程执行</p><ol start="5"><li>异步请求线程</li></ol><p>负责执行异步请求一类的操作，如Promis，ajax，axios<br>主线程执行到了异步任务后，将任务讲给异步请求线程执行，执行完后，将回调函数添加到微任务队列，等待JS线程执行</p><h2 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h2><p><strong>浏览器中的Event-loop</strong><br>浏览器中的事件循环机制中有两中队列，一个是宏任务一个是微任务，当主线程遇到同步操作时加入宏任务，遇到异步操作时加入微任务。常见的宏任务：setTimeout,setInterval，script（整段代码），I/O操作，UI渲染常见的微任务：Promise.then,MutationObserver<br>&emsp;&emsp;其中的执行机制是当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。其中微任务是不打断的直接执行完一整个队列的任务。</p><h3 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h3><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><h3 id="一些题目解读"><a href="#一些题目解读" class="headerlink" title="一些题目解读"></a>一些题目解读</h3><p>可以通过一个例子来进行分析：</p><ol><li><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-keyword">await</span>  async2().then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(_));        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 return&#x27;</span>;    &#125;    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 promise&#x27;</span>)).then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 then&#x27;</span>));        <span class="hljs-keyword">await</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 await&#x27;</span>);        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2 end&#x27;</span>);        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async2 return&#x27;</span>;    &#125;    async1().then(<span class="hljs-function"><span class="hljs-params">_</span>=&gt;</span><span class="hljs-built_in">console</span>.log(_,<span class="hljs-string">&#x27;async1 then&#x27;</span>));    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;settimeout&#x27;</span>);    &#125;,<span class="hljs-number">0</span>);    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;function1&#x27;</span>);    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;function2&#x27;</span>);    &#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>)</code></pre>在这个例子里：</li></ol><ul><li>首先<strong>输出</strong><code>script start</code></li><li>然后是<code>async1</code>的内容，此刻<code>await</code>执行<code>async2</code><strong>输出</strong><code>async2 promise</code>,然后<code>then</code>进入微任务</li><li>然后下面的<code>await</code><strong>输出</strong><code>async2 await</code>，然后后面的阻塞，进入微任务</li><li>然后继续执行，<strong>输出</strong><code>promise</code>，<code>then</code>进入微任务</li><li>然后<strong>输出</strong><code>script end</code></li><li>此时宏任务执行完一轮</li><li>微任务开始执行，先<strong>输出</strong><code>async2 then</code>，<code>async2 end</code>，然后<code>return</code>值进入微任务，同一批次的微任务中继续执行<strong>输出</strong><code>function1</code>，然后<code>2then</code>又进入微任务</li><li>继续执行微任务，此时先<strong>输出</strong><code>async2 return</code>，然后<code>async1</code>的<code>await</code>后的进入微任务</li><li><strong>输出</strong><code>function2</code></li><li>在执行微任务<strong>输出</strong><code>async1 end</code>，然后<code>1return</code>进入<code>async1().then(_=&gt;console.log(_,&#39;async1 then&#39;));</code>的微任务</li><li><strong>输出</strong><code>async1 return</code>,<code>async1 then</code>，微任务为空，执行宏任务</li><li><strong>输出</strong><code>settimeout</code></li></ul><p>最终顺序为</p><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> startasync2 promiseasync2 awaitpromise<span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span>async2 <span class="hljs-keyword">then</span>async2 <span class="hljs-keyword">end</span>function1async2 <span class="hljs-literal">return</span>function2async1 <span class="hljs-keyword">end</span>async1 <span class="hljs-literal">return</span>async1 <span class="hljs-keyword">then</span>settimeout</code></pre><ol><li><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e1&#x27;</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(r,j)</span>=&gt;</span>&#123;r()&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise3&#x27;</span>);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout3&#x27;</span>)    &#125;,<span class="hljs-number">0</span>)&#125;)<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1&#x27;</span>)    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(r,j)</span>=&gt;</span>&#123;r()&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>)    &#125;)&#125;,<span class="hljs-number">5000</span>)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e2&#x27;</span>)<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(r,j)</span>=&gt;</span>&#123;r(<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>))&#125;).<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2&#x27;</span>)    &#125;,<span class="hljs-number">0</span>)&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;e3&#x27;</span>)</code></pre>在这个例子里：</li></ol><ul><li>主线程<code>main</code>进入栈执行操作，此时执行<code>script</code>代码，会把<strong>输出</strong><code>e1</code></li><li>之后遇到<code>Promise.then</code>，会将其加入微任务队列</li><li>再往下执行，遇到<code>setTimeout</code>，将其加入定时器线程，等待计数完成后加入宏任务队列</li><li>再往下执行<strong>输出</strong><code>e2</code></li><li>往下执行遇到<code>Promise</code>，先将<code>resolve</code>输出1，然后将<code>then</code>加入微任务队列</li><li>再往下执行<strong>输出</strong>e3，此时<code>script</code>代码执行完毕，立刻搜索微任务是否为空，不为空就立刻执行此时微任务的队列</li><li>此时微任务队列先进先出输出<code>promise3</code>，然后遇到<code>setTimeout</code>，将其加入定时器线程，等待计数完成后加入宏任务队列</li><li>再往下执行第二个微任务，输出<code>promise2</code>，然后遇到<code>setTimeout</code>，将其加入定时器线程，等待计数完成后加入宏任务队列</li><li>再往下执行发现微任务队列为空，去宏任务队列去寻找是否有任务</li><li>在宏任务发现此时先执行完的<code>setTimeout3</code>，输出<code>timeout3</code>，将<code>then</code>加入微任务队列</li><li>执行完该次宏任务后立刻寻找微任务队列，为空，去寻找宏任务队列</li><li>在宏任务发现先执行完的<code>setTimeout2</code>任务，执行<strong>输出</strong><code>timeout2</code></li><li>此时任务队列为空，等待新任务加入</li><li>此时<code>setTimeout1</code>计数完毕，加入宏任务队列，并执行，<strong>输出</strong><code>timeout1</code>，将<code>then</code>加入微任务队列</li><li>执行完该次宏任务后立刻寻找微任务队列，并执行，<strong>输出</strong><code>promise1</code><br>最终结果为<pre><code class="hljs mercury">e1 e2 <span class="hljs-number">1</span> e3 promise3 promise2 timeout3 timeout2 timeout1 <span class="hljs-keyword">promise</span></code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器中的缓存方式</title>
    <link href="/2020/11/24/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/"/>
    <url>/2020/11/24/browser/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201130133052.png"></p><h2 id="浏览器缓存（http缓存）"><a href="#浏览器缓存（http缓存）" class="headerlink" title="浏览器缓存（http缓存）"></a>浏览器缓存（http缓存）</h2><p>&emsp;&emsp;先看看浏览器发起请求和，内部是个什么流程：<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201130152153.png"><br>&emsp;&emsp;如图，浏览器会先问自己有没有缓存，缓存是否过期了，然后去问服务器关于资源的问题。如此我们先解决第一个问题，浏览器自己的缓存是放在什么地方了。<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201130152429.png"><br>&emsp;&emsp;从浏览器的<code>network</code>里可以看到资源会放在<code>memory cache</code>和<code>disk cache</code>里。</p><h3 id="memory-cache-和-disk-cache"><a href="#memory-cache-和-disk-cache" class="headerlink" title="memory cache 和 disk cache"></a>memory cache 和 disk cache</h3><h4 id="memory-cache"><a href="#memory-cache" class="headerlink" title="memory cache"></a>memory cache</h4><p>顾名思义，就是将资源缓存到<em>内存</em>中，等待下次访问时不需要重新下载资源，而直接从内存中获取。<code>Webkit</code>早已支持<code>memoryCache</code>。目前<code>Webkit</code>资源分成两类</p><ul><li>一类是<strong>主资源</strong>，比如<em>HTML页面</em>，或者<em>下载项</em></li><li>一类是<strong>派生资源</strong>，比如HTML页面中内嵌的<em>图片</em>或者<em>脚本链接</em></li></ul><p>分别对应代码中两个类：<code>MainResourceLoader</code>和<code>SubresourceLoader</code>。虽然<code>Webkit</code>支持<code>memoryCache</code>，但是也只是针对派生资源，它对应的类为<code>CachedResource</code>，用于保存原始数据（比如<code>CSS，JS</code>等），以及解码过的图片数据。</p><h4 id="diskCache"><a href="#diskCache" class="headerlink" title="diskCache"></a>diskCache</h4><p>顾名思义，就是将资源缓存到<em>磁盘</em>中，等待下次访问时不需要重新下载资源，而直接从磁盘中获取，它的直接操作对象为<code>CurlCacheManager</code>。它与<code>memoryCache</code>最大的区别在于，<strong>当退出进程时，内存中的数据会被清空，而磁盘的数据不会</strong>，所以，当下次再进入该进程时，该进程仍可以从<code>diskCache</code>中获得数据，而<code>memoryCache</code>则不行。<code>diskCache</code>与<code>memoryCache</code>相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的<code>url</code>，然后再分别存储该<code>url</code>的<code>response</code>信息和<code>content</code>内容。<code>Response</code>信息最大作用就是利用<code>Last-Modified</code>等标记来判断服务器上该<code>url</code>的<code>content</code>内容是否被修改。</p><h4 id="读取缓存的优先级"><a href="#读取缓存的优先级" class="headerlink" title="读取缓存的优先级"></a>读取缓存的优先级</h4><ol><li>先看内存有没有，有就直接加载</li><li>没有就在看磁盘有没有，有就直接加载</li><li>还没有就只能访问网络请求拿数据</li><li>拿到后存到对应的地方</li></ol><h3 id="浏览器缓存分类"><a href="#浏览器缓存分类" class="headerlink" title="浏览器缓存分类"></a>浏览器缓存分类</h3><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h3><p>&emsp;&emsp;强缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。<br>缓存是否存在取决的我们是否<em>缓存了</em>和是否<em>有效期过了</em>，这里就涉及到两个头字段的属性了。</p><ul><li>Expires</li></ul><p>该字段是 <code>http1.0</code> 时的规范，它的值为一个绝对时间的GMT格式的时间字符串，比如Expires:Mon, 30 Nov 2020 02:23:37 GMT。这个时间代表着这个资源的<em>失效时间</em>，在此时间之前，就可以命中缓存。但是这种方式有较大的问题，因为是利用时间戳进行判断的，一旦系统的时间有问题，就会出现缓存混乱的问</p><ul><li>Cache-Control</li></ul><p><code>Cache-Control</code> 是<code>http1.1</code>时出现的<code>header</code>信息，主要是利用该字段的 <code>max-age</code>值来进行判断，它是一个相对时间，例如<code>Cache-Control:max-age=3600</code>，代表着资源的有效期是3600秒。</p><p>&emsp;&emsp;此外，<code>cache-control</code>除了<code>max-age</code>字段外，还有下面几个比较常用的设置值：</p><ul><li>no-cache：需要进行协商缓存，发送请求到服务器确认是否使用缓存。</li><li>no-store：禁止使用缓存，每一次都要重新请求数据。</li><li>public：可以被所有的用户缓存，包括终端用户和CDN等中间代理服务器。</li><li>private：只能被终端用户的浏览器缓存，不允许CDN等中继缓存服务器对其缓存。</li></ul><p>&emsp;&emsp;<code>Cache-Control</code>与<code>Expires</code>可以在服务端配置同时启用，同时启用的时候 <code>Cache-Control</code> <strong>优先级高</strong>。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>&emsp;&emsp;协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。<br>&emsp;&emsp;其中<code>header</code>中的缓存标识有：<code>if-Modified/if-Modified-Since</code>和<code>Etag/if-none-match</code>，其中<code>Etag/if-none-match</code>会先被服务器验证，之后再去查验<code>if-Modified</code>的情况</p><ul><li>if-Mif-Modifiedif-Modified/if-Modified-Since<br>第一次请求一个资源的时候，服务器会在头部加上<code>if-Modified</code>字段来告诉浏览器最后一次修改的时间什么时候。然后浏览器再次请求相同资源时，会附加<code>if-Modified-Since</code>字段，该字段为之前<code>if-Modified</code>的值，服务器据此判断资源是否被修改过，如果没变化，就返回<code>304</code>，告诉浏览器用之前的资源就好了，这资源咱就不再重复传了。</li><li>Etag/if-none-match<br>和上面情况相同，不过返回的值是一个<code>Etag</code>校验码，用来标识资源是否有变动，不过在确认没变化后除了返回<code>304</code>，还有传回一个<code>Etag</code>。<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201130155850.png"><br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201130155821.png"></li></ul><h2 id="本地缓存"><a href="#本地缓存" class="headerlink" title="本地缓存"></a>本地缓存</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>&emsp;&emsp;<code>Cookie</code> 是直接存储在浏览器中的一小串数据。它们是 <code>HTTP</code> 协议的一部分，由 <code>RFC 6265</code> 规范定义。<br>&emsp;&emsp;<code>Cookie</code> 通常是由 <code>Web</code> 服务器使用响应 <code>Set-Cookie HTTP-header</code> 设置的。然后浏览器使用 <code>Cookie HTTP-header</code> 将它们自动添加到（几乎）每个对相同域的请求中。<br>&emsp;&emsp;最常使用的就是登录验证，整个过程中，客户端登录后，服务器在响应中使用 <code>Set-Cookie HTTP-header</code> 来设置具有唯一“会话标识符<code>（session identifier）</code>的 <code>cookie</code>。下次如果请求是由相同域发起的，浏览器会使用<code>Cookie HTTP-header</code>通过网络发送 <code>cookie</code>。所以服务器就知道是谁发起了请求。</p><h3 id="sessionStorage"><a href="#sessionStorage" class="headerlink" title="sessionStorage"></a>sessionStorage</h3><p>&emsp;&emsp;<code>sessionStorage</code>属性允许你访问一个，对应当前源的<code>session Storage</code>对象。它与<code>localStorage</code>相似，不同之处在于<code>localStorage</code>里面存储的数据没有过期时间设置，而存储在 <code>sessionStorage</code> 里面的数据在页面会话结束时会被清除。</p><ul><li>页面会话在浏览器打开期间一直保持，并且重新加载或恢复页面仍会保持原来的页面会话</li><li>在新标签或窗口打开一个页面时会复制顶级浏览会话的上下文作为新会话的上下文，这点和 session cookies 的运行方式不同</li><li>打开多个相同的URL的Tabs页面，会创建各自的sessionStorage。</li><li>关闭对应浏览器窗口（Window）/ tab，会清除对应的sessionStorage。</li></ul><h3 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h3><p>&emsp;&emsp;<code>localStorage</code> 最主要的特点是：</p><ul><li>在同源的所有标签页和窗口之间共享数据。</li><li>数据不会过期。它在浏览器重启甚至系统重启后仍然存在。</li></ul><p>&emsp;&emsp;只读的<code>localStorage</code>属性允许你访问一个<code>Document</code>源（origin）的对象 <code>Storage</code>；存储的数据将保存在浏览器会话中。<code>localStorage</code> 类似 <code>sessionStorage</code>，但其区别在于：存储在 <code>localStorage</code> 的数据可以长期保留；而当页面被关闭时，存储在 <code>sessionStorage</code> 的数据会被清除。<br>&emsp;&emsp;无论数据存储在 <code>localStorage</code> 还是 <code>sessionStorage</code> ，它们都特定于页面的协议。另外，<code>localStorage</code> 中的<strong>键值对总是以字符串的形式存储</strong>。 (需要注意, 和js对象相比, 键值对总是以字符串的形式存储意味着数值类型会自动转化为字符串类型).</p><h3 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h3><p>&emsp;&emsp;<code>IndexedDB</code> 是一个用于在浏览器中储存较大数据结构的 Web API, 并提供<strong>索引功能</strong>以实现高性能查找. 像其他基于 <code>SQL</code> 的 关系型数据库管理系统 (RDBMS) 一样, <code>IndexedDB</code> 是一个事务型的数据库系统. 然而, 它是使用 JavaScript 对象而非列数固定的表格来储存数据的.它比 <code>localStorage</code> 强大得<br>多。</p><ul><li>通过键和多种键的类型来存储几乎任何类型的值。</li><li>支撑事务的可靠性</li><li>支持键范围查询、索引</li><li>和 localStorage 相比，它可以存储更大的数据量。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>http协议初解</title>
    <link href="/2020/11/23/network/http%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/11/23/network/http%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="http概述"><a href="#http概述" class="headerlink" title="http概述"></a>http概述</h2><p>&emsp;&emsp;<strong>超文本传输协议</strong><code>HTTP</code>是分布式、协作的、超媒体信息系统的应用层协议。它是通用的，<em><strong>无状态</strong></em>的协议，可以用在超文本用途之外的许多任务，如名称服务器和分布式目标管理系统，通过扩展它的请求方法，错误码和头部。HTTP的一个特性是数据表示的引入和协商，允许系统建立独立的传输数据。<br>&emsp;&emsp;我们就这个名字<strong>超文本传输协议</strong>进行分析，可以解构为<em>超文本</em>，<em>传输</em>，<em>协议</em></p><ol><li>超文本<br>什么是超文本？超越文本的内容就是超文本，早期的计算机是以文字进行传输的，后来的极速发展导致更多形式的数据可以进行传输，图像视频音频等，所以这些“文本”就被称为<strong>超文本</strong>；</li><li>传输<br>我们要进行终端与终端间的传输，我们需要把文本转成二进制通过物理链路进行传输，其中双方还需要对传输进行响应，才能达到传输的目的<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/1606103485414.jpg" alt="传输模型"></li><li>协议<br>计算机之间通信需要互相遵循的规则，就是网络协议。http协议就是一种计算机之间通信的的规范和约束。<h2 id="计算机网络协议模型"><a href="#计算机网络协议模型" class="headerlink" title="计算机网络协议模型"></a>计算机网络协议模型</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3>&emsp;&emsp;ISO（国际标准化组织）提出来计算机网络应该按照7层来组织，于是诞生了OSI七层模型。<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201123130249.png" alt="七层模型"><br>我们从上往下看这七层模型都发挥了什么作用：</li></ol><ul><li><strong>应用层</strong><br>特定网络应用协议存放的一层，为我们特定的网络应用提供服务我们平时的超文本传输协议<code>HTTP</code>，电子邮件传输的<code>SMTP</code>，文件传输的<code>FTP</code>，域名解析的<code>DNS</code>等等。</li><li><strong>表示层</strong><br>主要对数据的操作，对数据进行加密、压缩或者描述，负责把下一层传来的数据转换成应用层能够使用的数据形式，把应用层的数据转换成适合网络传输的格式。</li><li><strong>会话层</strong><br>为不同机器间创建和管理会话的一层</li><li><strong>传输层</strong><br>传输层是承上启下的一层，下三层主要是进行数据的传输，上三层主要进行数据的处理，传输层主要就是建立正确的端到端的通信，确保保文的正确传输，该层主要有两种协议，分别是可靠传输<code>TCP</code>和不可靠的<code>UDP</code>。<ul><li>TCP：一种面向连接的、可靠的、基于字节流的传输层通信协议（TCP，Transmission Control Protocol），建立通信前会先建立一个TCP连接，类似于打电话中的“喂，你是xxx吗”，回答“我是xxx”，通过三次握手建立稳定的连接，在结束连接是会进行四次挥手断开连接。<br>&emsp;&emsp;在TCP协议中会通过对数据进行检验确保数据的正确性和合法性，通过超时重传的方式保证连接的可靠性，通过用拥塞控制算法（AIMD算法）实现对网络传输的控制，通过滑动窗口的方式达到流量控制的目的。</li><li>UDP：一个无连接的传输协议，该协议称为用户数据报协议（UDP，User Datagram Protocol）。UDP 为应用程序提供了一种无需建立连接就可以发送封装的IP数据包的方法.<br>&emsp;&emsp;由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务机可同时向多个客户机传输相同的消息。正是因为UDP在传输数据前不建立连接，不对数据报进行检查与修改，无须等待对方的应答，所以会出现分组丢失、重复、乱序，应用程序需要负责传输可靠性方面的所有工作。也正是因此，UDP具有较好的实时性，工作效率较TCP协议高；而且因为UDP段结构比TCP的段结构简单，因此网络开销也小。很适合分发信息的操作，哪怕信息错误，很快就会被新的信息替代，平时的实时视频音频大多会使用UDP。</li></ul></li><li><strong>网络层</strong><br>负责在网络中找到合适的路径抵达我们的目标网络，通过路由算法和寻址等方法建立起合适的路径。</li><li><strong>链路层</strong><br>数据链路层就是实现物理信号和数据帧转化，接收来自物理层的位流形式的数据，并封装成帧，传送到上一层；同样，也将来自上层的数据帧，拆装为位流形式的数据转发到物理层；并且，还负责处理接收端发回的确认帧的信息，以便提供可靠的数据传输。</li><li><strong>物理层</strong><br>物理层的主要功能就是利用传输介质(例如：网线，无线电波，光)为数据链路层提供物理连接，实现比特流的透明传输。<br>&emsp;&emsp;以上，建立在该网络模型之上，HTTP可以实现两点之间文字视频等超文本数据的传输。<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201123130640.png"><h3 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP/IP 四层模型"></a>TCP/IP 四层模型</h3>&emsp;&emsp;在TCP/IP中会话层和表示层被放在了应用层中，其他层主要内容是一样的。<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201125092256.png" alt="TCP四层"><br>&emsp;&emsp;其上的两层分别是以下内容，其他层作用一样。</li><li><strong>应用层</strong><br>主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等。</li><li><strong>传输层</strong><br>主要是有可靠传输的TCP协议，特别高效的UDP协议。主要负责传输应用层的数据包。</li></ul><h2 id="浏览器点击链接后的流程"><a href="#浏览器点击链接后的流程" class="headerlink" title="浏览器点击链接后的流程"></a>浏览器点击链接后的流程</h2><p>处理流程：<br>1、输入网址并回车<br>2、通过DNS解析域名，得到地址给浏览器<br>3、浏览器发送HTTP请求<br>4、服务器处理请求<br>5、服务器返回HTML响应<br>6、浏览器处理HTML页面<br>7、继续请求其他资源<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201124110413.png"></p><h2 id="HTTP工作流程"><a href="#HTTP工作流程" class="headerlink" title="HTTP工作流程"></a>HTTP工作流程</h2><p><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201123204750.png"><br>一次HTTP操作称为一次事务，可以分为四步：<br>1、首先客户和服务器需要建立连接，用户点击一个链接或者发出一次请求，HTTP请求开始工作<br>2、建立连接成功后，客户发送一个HTTP请求给服务器</p><ul><li>HTTP请求组成：请求行、消息报头、请求正文，<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201124113415.png"></li><li>请求的内容是以一个方法符号开头，后面跟着请求的<code>URL</code>、协议版本号、客户信息等别的可能的内容</li></ul><p><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201124113416.png"><br>3、服务器收到请求后，给予相应的响应信息</p><ul><li>HTTP响应组成：状态行、消息报头、响应正文。</li><li>内容包括：服务器HTTP协议的版本，服务器发回的响应状态代码和状态代码的文本描述、服务器信息等别的可能的内容<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201124113711.png"></li></ul><p>4、客户端收到服务器返回的信息通过浏览器显示在用户的显示屏上，确定没问题后断开连接</p><p>其中HTTP请求后返回的状态码不同的开头数字分别代表了不同的意义</p><h3 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h3><p>所有HTTP响应的第一行都是状态行，依次是当前HTTP版本号，3位数字组成的状态代码，以及描述状态的短语，彼此由空格分隔。状态代码的第一个数字代表当前响应的类型：</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">1xx</td><td align="center">消息</td><td align="center">请求已被服务器接收，继续处理</td></tr><tr><td align="center">2xx</td><td align="center">成功</td><td align="center">请求已成功被服务器接收、理解、并接受</td></tr><tr><td align="center">3xx</td><td align="center">重定向</td><td align="center">需要后续操作才能完成这一请求</td></tr><tr><td align="center">4xx</td><td align="center">请求错误</td><td align="center">请求含有词法错误或者无法被执行</td></tr><tr><td align="center">5xx</td><td align="center">服务器错误</td><td align="center">服务器在处理某个正确请求时发生错误</td></tr></tbody></table><p>虽然<code>RFC 2616</code>中已经推荐了描述状态的短语，例如<code>200 OK</code>，<code>404 Not Found</code>，但是WEB开发者仍然能够自行决定采用何种短语，用以显示本地化的状态描述或者自定义信息。<br>&emsp;&emsp;关于状态码，有些有意思的图解，虽然有些味道，但是描述的还挺形象的。<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201124161902.png"></p><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p>TCP的建立连接断开连接是通过三次握手四次挥手实现的，要理解这种连接方式，我们需要先知道<strong>TCP报头</strong>的组成方式，如下如所示：<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201123203435.png"><br>其中比较重要的就是序号、确认号和标识位：</p><ol><li>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</li><li>确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。（千万不要与标志位中的ACK搞混，这两个不是一个东西）</li><li>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：<ul><li>URG：紧急指针（urgent pointer）有效。</li><li>ACK：确认序号是否有效，一般置为1。</li><li>PSH：提示接收端应用程序立即从 TCP 缓冲区把数据读走。接收方应该尽快将这个报文交给应用层。</li><li>RST：重置连接。对方要求重新建立连接，复位。</li><li>SYN：请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为 1</li><li>FIN：释放一个连接。</li></ul></li></ol><p>&emsp;&emsp;<strong>三次握手四次挥手流程</strong><br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/20201124115039.png"><br>&emsp;&emsp;我们详细解读一下这个图的流程：</p><ol><li><strong>第一次握手：</strong><br>首先，客户端发出请求，请求的标志符<code>SYN</code>为1，随意生成一个seq序号，告诉服务器“我想建立连接”，此时客户端进入<code>SYN_SENT</code>已发送阶段</li><li><strong>第二次握手：</strong><br>服务器收到请求后，从<code>LISTEN</code>状态转成<code>SYN_RCVO</code>已收到阶段，然后发回请求，请求的标志符<code>SYN</code>为1，<code>ACK</code>为客户端的seq序号+1，确认是否之前的请求有效，随意生成的一个seq序号，告诉客户端“我同意连接，你准备好连接了吗”</li><li><strong>第三次握手：</strong><br>客户端收到服务器确认后，进入<code>ESTABLISHED</code>已连接状态，然后发回请求，标志符<code>ACK</code>为服务器的seq序号+1，告诉服务器“我准备好连接了”，服务器收到后也进入<code>ESTABLISHED</code>已连接状态</li><li>自此正式建立连接，进行正常的数据交互</li><li><strong>第一次挥手：</strong><br>结束数据交互后，要结束连接，此时客户端发送<code>FIN</code>告诉服务器“我要结束连接了”，并进入<code>FIN-WAIT-1</code>终止等待1状态</li><li><strong><em>第二次挥手：</em></strong><ul><li>服务器收到请求后，立刻发出<code>ACK</code>标志的确认请求，告诉客户端“我知道了”，此时客户端进入<code>FIN-WAIT-2</code>终止等待2状态，等待服务器发出连接释放的请求。</li><li>随后服务器进入<code>CLOSEWAIT</code>（关闭等待）状态，TCP进程去询问应用层是否没有数据要传输了，此刻如果有数据那么依旧会进行数据传输，客户端也会接收，</li></ul></li><li><strong>第三次挥手：</strong><br>当服务器知道没有数据要发送时，发送<code>FIN</code>报文，告知客户端“要断开连接了”，此时服务器进入<code>LAST-ACK</code>最后确认状态</li><li><strong>第四次挥手：</strong><br>客户端收到报文后，立刻发出确认报文，告知“已知晓”，然后进入<code>TIME_WAIT</code>时间等待状态，在结束时间等待后才会彻底释放TCP连接，至此整个TCP连接完成。</li></ol><h2 id="HTTP的优劣"><a href="#HTTP的优劣" class="headerlink" title="HTTP的优劣"></a>HTTP的优劣</h2><p>言归正传，我们来看看HTTP协议的优点和缺点：</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>HTTP的优势很明显，如下几个是比较突出的：</p><ol><li>简单灵活易扩展<br>因为HTTP的只规定了基本格式，空格分隔单词，换行分隔字段等。其他地方部分都可以由开发者自由定义，所以特别的灵活易扩展</li><li>可靠传输<br>因为使用了TCP/IP，所以继承了TCP，具备可靠传输的特性。</li><li>无状态<br>因为服务器不需要记忆这些状态，所以既能减轻服务器负担又能简化请求。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>同时HTTP也有一下缺点：</p><ol><li>无状态<br>因为无状态，所以无法处理连续事务，不过服务端也发展出了<code>Cookie</code>来进行记录。</li><li>明文传输<br>因为HTTP的明文传输，所以很容易被人截获具体内容，非常不安全。</li><li>队头阻塞<br>因为HTTP的采用了TCP协议，所以一旦某个连接很长，那么会导致其他连接被阻塞。</li></ol><h2 id="HTTP各版本的区别"><a href="#HTTP各版本的区别" class="headerlink" title="HTTP各版本的区别"></a>HTTP各版本的区别</h2><h3 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h3><p>&emsp;&emsp;HTTP0.9的主要内容<br>&emsp;&emsp;1991年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时。</p><h3 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h3><p>&emsp;&emsp;HTTP1.0的主要内容</p><ul><li>任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。</li><li>除了<code>GET</code>命令，还引入了<code>POST</code>命令和<code>HEAD</code>命令。</li><li>http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。只使用 <code>header</code> 中的 <code>If-Modified-Since</code> 和 <code>Expires</code> 作为缓存失效的标准。</li><li>不支持断点续传，也就是说，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 <code>IP</code>，所以请求消息中的 <code>URL</code> 并没有传递主机名<h3 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h3>HTTP1.1的主要内容</li><li>http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。</li><li>引入了<strong>持久连接</strong>（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，默认是<code>Connection: keep-alive</code>，即开启，设置<code>Connection: close</code>手动关闭。配合<code>Keep-Alive: timeout=5, max=1000</code>来设定连接时长。其中timeout指定一个空闲连接需要保持打开状态而最小时长（单位：秒）。max指定此次连接的最大请求数。</li><li>引入了<strong>管道机制</strong>（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率，会造成队头阻塞。</li><li>HTTP 1.1 中新增加了 E-tag，If-Unmodified-Since, If-Match，If-None-Match 等缓存控制标头来控制缓存失效。</li><li>支持断点续传，通过使用请求头中的 Range 来实现。</li><li>使用了<strong>虚拟网络</strong>，因为在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。所以HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li></ul><p><strong>HTTP1.*的<em>主要问题</em></strong></p><ol><li>因为持久连接的缘故，如果某些文件频繁的被请求，那么keep-alive导致了文件被请求之后还保持了不必要的连接很长时间，这会使得使得服务器性能下降。</li><li>因为管道的机制，所以所有的通信都是在管道内按序进行的，一旦某个连接持续时间过久，会导致整体任务被阻塞，这就是队头阻塞。<br>&emsp;&emsp;<h3 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h3></li></ol><ul><li>二进制分帧<br>这是一次彻底的二进制协议，以二进制代替原本的明文传输，头信息和数据体都是二进制，并且统称为”帧”：头信息帧和数据帧。</li><li>头部压缩<br>HTTP 1.1版本会出现 <code>「User-Agent、Cookie、Accept、Server、Range」</code> 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li><li>多路复用<br>复用TCP连接，不断的发帧，每帧的<code>stream identifier</code>都标明这一帧属于哪个流，然后在对方接收时，根据<code>stream identifier</code>拼接每个流的所有帧组成一整块数据。把HTTP/1.1 每个请求都当作一个流，那么多个请求变成多个流，请求响应分成多个帧，这样都个连接可以在一个连接里实现数据交换，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题、减少了TCP连接数，同时解决的TCP慢启动的问题。</li><li>服务器推送<br>允许服务器未经请求，主动向客户端发送资源，即服务器推送。<ul><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li></ul></li><li>请求优先级<br>可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul><p>综上，大致是HTTP的各个版本的一些特点和TCP的连接形式，在HTTP上还有一个HTTPS，虽然他只是在HTTP上套了一层加密，涉及了密码学、TLS/SSL，所以其中的门道也不少，可惜这里地方太小写不下了。</p><p>参考：<br>[1]<a href="https://juejin.cn/post/6857287743966281736#heading-27">https://juejin.cn/post/6857287743966281736#heading-27</a><br>[2]<a href="https://juejin.cn/post/6844903667569541133#heading-35">https://juejin.cn/post/6844903667569541133#heading-35</a></p>]]></content>
    
    
    <categories>
      
      <category>http</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器概述</title>
    <link href="/2020/11/23/browser/%E6%A6%82%E8%BF%B0/"/>
    <url>/2020/11/23/browser/%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="现代浏览器历史"><a href="#现代浏览器历史" class="headerlink" title="现代浏览器历史"></a>现代浏览器历史</h2><ul><li>1990年：蒂姆伯纳斯李开发了第一个网页浏览器WorldWideWeb，后来改名为Nexus。WorldWideWeb浏览器支持早期的HTMl标记语言，很简单，只支持文本、简单的样式表、电影、声音、图片等资源的显示。</li><li>1993年：马克安德森领导的团队开发了第一个具有影响力的浏览器Mosaic，这就是后来有名的Netscape Navigator。</li><li>1995年：微软推出了Internet Explorer，内置在windows系统中，和Netscape展开了第一次浏览器大战。</li><li>1998年：Netscape公司因为微软的商业策略市场份额下降，随后开放了Netscape Navigator源代码，成立了Mozilla基金会，之后开启了第二次浏览器大战。同年1998年11月24日，美国在线（AOL）宣布将以42亿美元的免税股票交换方式收购Netscape Communications。</li><li>2003年：苹果公司发布了Safari浏览器，时代华纳（前美国在线时代华纳）解散了Netscape。</li><li>2005年：苹果公司开源了浏览器中的核心代码，基于此发起了一个新的开源项目Webkit</li><li>2008年：谷歌以WebKit内核创建了一个新的浏览器项目Chromium，以此发布了Chrome浏览器。</li></ul><ol><li>现代浏览器的特征</li></ol><ul><li>网络</li><li>资源管理</li><li>网页浏览</li><li>多页面管理</li><li>插件和拓展</li><li>账户和同步</li><li>安全机制</li><li>开发者工具</li></ul><ol start="2"><li>现代浏览器的结构</li></ol><ul><li>用户界面（User Interface）</li><li>浏览器引擎（Browser Engine）</li><li>渲染引擎（Rendering Engine）</li><li>网络（Networking）</li><li>XML解析器（XML Parser）</li><li>显示后端（Display Backend）</li><li>数据持久层（Data Persistence）<br><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/liulanqi.png"></li></ul><ol><li>常见的渲染引擎<table><thead><tr><th>渲染引擎</th><th>浏览器</th></tr></thead><tbody><tr><td>Trident</td><td>IE、Edge(旧)</td></tr><tr><td>Gecko</td><td>Firefox</td></tr><tr><td>WebKit</td><td>Safari</td></tr><tr><td>Blink(WebKit fork)</td><td>Chromium/Chrome/Opera/Edge</td></tr></tbody></table></li></ol><h2 id="渲染引擎结构和工作流程"><a href="#渲染引擎结构和工作流程" class="headerlink" title="渲染引擎结构和工作流程"></a>渲染引擎结构和工作流程</h2><h3 id="总流程"><a href="#总流程" class="headerlink" title="总流程"></a>总流程</h3><p><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/render.png"><br>结合这张渲染引擎的过程，可以得知</p><ul><li>通过HTML/JavaScript/CSS等文件作为输入–&gt;</li><li>解析HTML转换成DOM Tree，把HTML的标签啥的转成DOM树的节点–&gt;</li><li>根据CSS的渲染规则和DOM树关联起来生成渲染树Render Tree–&gt;</li><li>根据渲染树生成布局树Layout of Render Tree–&gt;</li><li>最后绘制渲染树–&gt;</li><li>展示页面<h3 id="每步详细流程"><a href="#每步详细流程" class="headerlink" title="每步详细流程"></a>每步详细流程</h3><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/render2.png"><br>三大件的代码进入浏览器之后，会通过HTML解析器、CSS解析器、JavaScript解释器，最终生成最后的渲染树给到Layout去进行布局树的构建，最后通过最终的Tree进行Painting绘制得到最后的页面。<br>其中因为Javascript可以操作CSS和DOM元素，所以JavaScript可以打断整个流程，所以<strong>我们最好是把JavaScript放在整个页面的最后来执行</strong>。<br>当其中的<strong>DOM发生变化后，整个RenderTree和Layout of Render Tree都要重新生成，然后重新绘制</strong>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器同源策略</title>
    <link href="/2020/11/22/browser/%E8%B7%A8%E5%9F%9F/"/>
    <url>/2020/11/22/browser/%E8%B7%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><p>&emsp;&emsp;同源策略（<code>Same origin policy</code>）是指在Web浏览器中，允许某个网页脚本访问另外一个网页的数据，但前提是这两个网页必须有相同的URL、主机名和端口号，一旦两个网站满足以上条件，这两个网站就被认定为具有相同来源。此策略可防止某个网页上的恶意脚本通过该页面的文档对象模型访问另一个网页上的敏感数据。</p><table><thead><tr><th align="center">URL</th><th align="center">说明</th><th align="center">是否通讯</th></tr></thead><tbody><tr><td align="center"><a href="http://www.abc.com/a.js">http://www.abc.com/a.js</a><br><a href="http://www.abc.com/b.js">http://www.abc.com/b.js</a></td><td align="center">相同域名下的不同文件</td><td align="center">ok</td></tr><tr><td align="center"><a href="http://www.abc.com:9090/a.js">http://www.abc.com:9090/a.js</a><br><a href="http://www.abc.com:2020/a.js">http://www.abc.com:2020/a.js</a></td><td align="center">不同的端口</td><td align="center">no</td></tr><tr><td align="center"><a href="http://www.abc.com/a.js">http://www.abc.com/a.js</a><br><a href="http://www.abd.com/a.js">http://www.abd.com/a.js</a></td><td align="center">不同域名</td><td align="center">no</td></tr><tr><td align="center"><a href="http://www.abc.com/a.js">http://www.abc.com/a.js</a><br><a href="https://www.abc.com/a.js">https://www.abc.com/a.js</a></td><td align="center">不同协议</td><td align="center">no</td></tr><tr><td align="center"><a href="http://b.abc.com/a.js">http://b.abc.com/a.js</a><br><a href="https://www.abc.com/a.js">https://www.abc.com/a.js</a></td><td align="center">主域名不同</td><td align="center">no</td></tr></tbody></table><p>&emsp;&emsp;简而言之就是必须要协议域名端口完全相同才不会触发非同源策略，不然都是属于跨域的，那么针对这种情况，我们可以有以下几种解决的方法。</p><h3 id="1、jsonp"><a href="#1、jsonp" class="headerlink" title="1、jsonp"></a>1、jsonp</h3><p>因为浏览器中有三种标签天生就支持跨域<code>&lt;img&gt;&lt;script&gt;&lt;link&gt;</code>，<code>jsonp</code>就是利用<code>script</code>标签的性质，通过<code>script</code>传输<code>JSON</code>数据。因为此方法比较简单，而且可以兼容性强，所以简单解决跨域问题是可以的，但是这种方法有很大的问题，因为是script标签传输JSON，所以：</p><ul><li>只能支持get方法</li><li>不安全，可能会受到XSS的攻击</li></ul><p>&emsp;&emsp;我在自己的服务器上搭建了一个简单的接口，返回一串callback(‘测试数据’)的字符串，可以实现跨域请求数据。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonp</span>(<span class="hljs-params">&#123;</span></span><span class="hljs-function"><span class="hljs-params">    url,</span></span><span class="hljs-function"><span class="hljs-params">    callback</span></span><span class="hljs-function"><span class="hljs-params">    &#125;</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>)        <span class="hljs-built_in">window</span>[callback] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>) </span>&#123;            resolve(data)            <span class="hljs-built_in">document</span>.body.removeChild(script)        &#125;        script.src = <span class="hljs-string">`<span class="hljs-subst">$&#123;url&#125;</span>?callback=<span class="hljs-subst">$&#123;callback&#125;</span>`</span>        <span class="hljs-built_in">document</span>.body.appendChild(script)        &#125;)    &#125;jsonp(&#123;    url: <span class="hljs-string">&#x27;http://xxx.xx.xx.xx:7777/api/test&#x27;</span>,    callback: <span class="hljs-string">&#x27;show&#x27;</span>    &#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(data)    &#125;)</code></pre><h3 id="2、document-domain-iframe"><a href="#2、document-domain-iframe" class="headerlink" title="2、document.domain + iframe"></a>2、document.domain + iframe</h3><p> 当仅仅只有子域不同时，我们只需要在js中强制设置<code>document.domain</code>为基础主域，就可以实现跨域<br> <pre><code class="hljs javascript"><span class="hljs-comment">//a.xxx.com/a.html</span>&lt;iframe id=<span class="hljs-string">&#x27;iframe&#x27;</span> src=<span class="hljs-string">&#x27;http://b.xxx.com/b.html&#x27;</span> style=<span class="hljs-string">&#x27;display:none;&#x27;</span>&gt;&lt;/iframe&gt;&lt;script&gt;    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;xxx.com&#x27;</span>;    <span class="hljs-keyword">var</span> user = <span class="hljs-string">&#x27;admin&#x27;</span>;&lt;/script&gt;<span class="hljs-comment">//b.xxx.com/b.html</span>&lt;script&gt;    <span class="hljs-built_in">document</span>.domain = <span class="hljs-string">&#x27;xxx.com&#x27;</span>;    <span class="hljs-comment">// 获取父窗口中变量</span>    alert(<span class="hljs-string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="hljs-built_in">window</span>.parent.user);&lt;/script&gt;</code></pre></p><p>其他的如<code>location.hash</code>,<code>window.name </code>都是类似的方法，但是个人觉得不好用，所以就略过吧。</p><h3 id="3、postMessage"><a href="#3、postMessage" class="headerlink" title="3、postMessage"></a>3、postMessage</h3><p>&emsp;&emsp;<code>window.postMessage()</code>方法提供了一种可控制的机制来安全地规避同源策略，安全地实现了Window对象之间的跨域通信。例如，在页面与其产生的弹出窗口之间，或在页面与嵌入其中的iframe之间。<br>&emsp;&emsp;大致上来说，一个窗口可以获取对另一个窗口的引用，例如：通过<code>targetWindow = window.opener</code>来获取另一个页面的对象，然后使用来<code>MessageEvent</code>在其上分派一个<code>targetWindow.postMessage()</code>，然后，接收窗口可以根据自身需要自由的处理此事件。传递给事件的参数<code>window.postMessage()</code>（即“消息”）通过<strong>事件对象</strong>暴露给接收窗口。</p><pre><code class="hljs javascript"><span class="hljs-comment">//9090</span> <span class="hljs-keyword">var</span> targetWindow = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;http://xxx.xxx.com:9090&#x27;</span>); targetWindow.posetMessage(<span class="hljs-string">&#x27;hello,i am 9090&#x27;</span>,<span class="hljs-string">&#x27;http://xxx.xxx.com:9091&#x27;</span>); targetWindow.addEventListener(<span class="hljs-string">&#x27;event&#x27;</span>,<span class="hljs-function"><span class="hljs-params">e</span>=&gt;</span>&#123;     <span class="hljs-keyword">if</span>(e.origin!==<span class="hljs-string">&#x27;https://xxx.xxx.com:9090&#x27;</span>)     <span class="hljs-keyword">return</span>     <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// i am 9091</span> &#125;,<span class="hljs-literal">false</span>)<span class="hljs-comment">//9091</span><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> &#123;  <span class="hljs-keyword">if</span> (event.origin !== <span class="hljs-string">&quot;http://xxx.xxx.com:9090&quot;</span>)    <span class="hljs-keyword">return</span>;  <span class="hljs-built_in">console</span>.log(e.data) <span class="hljs-comment">// hello,i am 9090</span>  event.source.postMessage(<span class="hljs-string">&#x27;i am 9091&#x27;</span>,event.origin);&#125;, <span class="hljs-literal">false</span>);</code></pre><h3 id="4、CORS"><a href="#4、CORS" class="headerlink" title="4、CORS"></a>4、CORS</h3><p><code>CORS</code>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>&emsp;&emsp;整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现<code>CORS</code>通信的关键是<strong>服务器</strong>。只要服务器实现了<code>CORS</code>接口，就可以跨源通信。</p><h3 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。<br>&emsp;只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：<code>HEAD</code>、<code>GET</code>、<code>POST</code></li><li>HTTP的头信息不超出以下几种字段：<code>Accept</code>、<code>Accept-Language</code>、<code>Content-Language</code>、<code>Last-Event-ID</code>、<code>Content-Type</code>（其中<code>Content-Type</code>只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code>）<br>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。**<em>凡是不同时满足上面两个条件，就属于非简单请求**</em>。<br>浏览器对这两种请求的处理，是不一样的。<h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4>&emsp;&emsp;浏览器发送简单请求时，会自动在头上加上<code>Origin</code>字段。<code>Origin</code>字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</li></ol><ul><li><p>如果服务器<code>Access-Control-Allow-Origin</code>规定的许可范围内没有这个值，会返回一个头信息中不包含<code>Access-Control-Allow-Origin</code>字段的响应，此时浏览器会检测到错误并抛出错误。此错误不能从状态码中发现。</p></li><li><p>如果在许可范围内，服务器返回的响应中会多处几个头字段</p><ul><li>1）Access-Control-Allow-Origin</li></ul><p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><ul><li>2）Access-Control-Allow-Credentials</li></ul><p>该字段可选。它的值是一个布尔值，表示是否允许发送<code>Cookie</code>。默认情况下，<code>Cookie</code>不包括在CORS请求之中。设为true，即表示服务器明确许可，<code>Cookie</code>可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送<code>Cookie</code>，删除该字段即可。</p><ul><li>3）Access-Control-Expose-Headers</li></ul><p>该字段可选。<code>CORS</code>请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。</p></li></ul><p>想要通过<code>CORS</code>发送<code>Cookie</code>，想要同时在服务器设置<code>Access-Control-Allow-Credentials</code>字段为<code>true</code>，另一方面，开发者必须在AJAX请求中打开<code>withCredentials</code>属性。</p><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-type">XMLHttpRequest</span>();xhr.withCredentials = <span class="hljs-literal">true</span>;</code></pre><p>同时如果要发送<code>Cookie</code>，<code>Access-Control-Allow-Origin</code>就不能设为<code>*</code>，必须指定明确的、与请求网页一致的域名。同时，<code>Cookie</code>依然遵循同源政策，只有用服务器域名设置的<code>Cookie</code>才会上传，<strong>其他域名的<code>Cookie</code>并不会上传</strong>，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的<code>Cookie</code>。</p><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><p>&emsp;&emsp;浏览器发现这是一个非简单请求时，会自动发出一个<strong>预检</strong>请求，要求服务器确认可以这样请求。<strong>预检</strong>请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。<br>其中，”预检”请求的头信息包括两个特殊字段：<br>（1）Access-Control-Request-Method<br>&emsp;&emsp;该字段是必须的，用来列出浏览器的<code>CORS</code>请求会用到哪些HTTP方法，如<code>PUT</code>，<code>DELETE</code><br>（2）Access-Control-Request-Headers<br>&emsp;&emsp;该字段是一个逗号分隔的字符串，指定浏览器<code>CORS</code>请求会额外发送的头信息字段<br>服务器收到请求后，会先进行<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>的检查，确认是否是可以跨域的请求：</p><ul><li>如果检查没问题，就会返回添加了相应头字段的响应</li><li>如果服务器否定了预检请求，会返回一个正常的<code>HTTP</code>回应，但是没有任何<code>CORS</code>相关的头信息字段。这时,浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获，在控制台报错。<br>其中正确返回的响应的头字段会加入一下几个字段：<br>（1）Access-Control-Allow-Methods<br>&emsp;&emsp;<strong>该字段必需</strong>，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。<br>（2）Access-Control-Allow-Headers<br>&emsp;&emsp;如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。<br>（3）Access-Control-Allow-Credentials<br>&emsp;&emsp;该字段与简单请求时的含义一样都是是否允许发送<code>Cookie</code>。<br>（4）Access-Control-Max-Age<br>&emsp;&emsp;该字段可选，用来指定本次预检请求的有效期，单位为秒。比如缓存时间设置为1728000秒（20天），那么在此期间，都不用发出另一条预检请求，此期间之前的预检请求会存活直到期。<h3 id="5、服务器中转"><a href="#5、服务器中转" class="headerlink" title="5、服务器中转"></a>5、服务器中转</h3>因为<strong>跨域是浏览器行为，不是服务器行为</strong>，所以实际上每次跨域请求都是到达服务器了的，只不过在回来的时候被浏览器限制了。所以我们可以通过服务器去实现访问，然后把数据从我们自己的同源中请求到。<h4 id="nginx代理"><a href="#nginx代理" class="headerlink" title="nginx代理"></a>nginx代理</h4>&emsp;&emsp;通过<code>nginx</code>代理我们要访问的地址，借助中转服务器去访问<pre><code class="hljs awk"><span class="hljs-regexp">//</span> proxy服务器server &#123;    listen       <span class="hljs-number">80</span>;    server_name  www.my.com;    location /api &#123;        <span class="hljs-regexp">//</span>移除api        rewrite ^<span class="hljs-regexp">/api/</span>(.*)$ /&amp;<span class="hljs-number">1</span> <span class="hljs-keyword">break</span>;        proxy_pass   http:<span class="hljs-regexp">//</span>www.target.com;  <span class="hljs-comment">#反向代理</span>        proxy_cookie_domain www.domain2.com www.domain1.com; <span class="hljs-comment">#修改cookie里域名</span>    &#125;&#125;</code></pre><h4 id="6、nodejs中间件代理"><a href="#6、nodejs中间件代理" class="headerlink" title="6、nodejs中间件代理"></a>6、nodejs中间件代理</h4>&emsp;&emsp;<code>node</code>做一层中间代理服务器，首先<code>node</code>接收接受客户端请求,然后将请求转发给目标服务器，<code>node</code>拿到目标服务器的响应数据，之后<code>node</code>将响应结果发给客户端，至此完成跨域请求。<h3 id="7、WebSocker协议"><a href="#7、WebSocker协议" class="headerlink" title="7、WebSocker协议"></a>7、WebSocker协议</h3><code>WebSocker</code>是<code>HTML5</code>的一种持久化协议，可以在服务端和客户端建立起双向的通信通道，实现持久的数据通信，一般都是用来做通信聊天的，既然可以进行数据交互，我们拿来跨域也是可以的，不过就是不方便而已啦</li></ul><p>&emsp;&emsp;综上，就这么几种解决跨域的方法，总结一下他们的差异：</p><ol><li>jsonp<br>需要目标服务器配合一个<code>callback</code>函数　</li><li>window.name+iframe<br>需要目标服务器响应<code>window.name</code></li><li>window.location.hash+iframe<br>同样需要目标服务器作处理</li><li>html5的postMessage+ifrme<br>这个也是需要目标服务器或者说是目标页面写一个postMessage，主要侧重于前端通讯</li><li>CORS<br>需要服务器设置header :Access-Control-Allow-Origin</li><li>服务器中转<br><code>nginx</code>反向代理或<code>node</code>代理中间层 这个方法一般很少有人提及，但是他可以不用目标服务器配合，不过需要你搭建一个中转<code>nginx</code>服务器，用于转发请求</li><li>WebSocker 双方都需要实现WebSocker，也不太方便<br>所以我还是比较喜欢CORS和中转的方法的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>浏览器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RESTFULL</title>
    <link href="/2020/11/09/RESTFULL/"/>
    <url>/2020/11/09/RESTFULL/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是RESTFUL架构"><a href="#什么是RESTFUL架构" class="headerlink" title="什么是RESTFUL架构"></a>什么是RESTFUL架构</h2><p>REST代表<code>Respersontational State Transfer</code>，通常理解为表现层状态转移，他是围绕资源展开的，每个组件都是资源，都是可以通过唯一的URL访问到的，REST体系将所有的内容都视为资源，这些资源可以是文本、HTML页面、图像、视频或者业务数据。<code>REST Server</code>只提供对资源的访问，<code>REST Client</code>访问和修改这些资源，REST可以使用各种的形式来表现这些资源，主要是使用JSON，也可以是Text或者XML。</p><h2 id="REST的约束条件"><a href="#REST的约束条件" class="headerlink" title="REST的约束条件"></a>REST的约束条件</h2><h3 id="客户端-服务器"><a href="#客户端-服务器" class="headerlink" title="客户端-服务器"></a>客户端-服务器</h3><p>&emsp;&emsp;通过将用户接口和数据存储的问题分开，提高了接口的可移植性。</p><h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>&emsp;&emsp;<code>RESTful Web</code>服务不应该在服务器保存客户端的状态，这种限制被称为无状态，客户端负责把上下文传递给服务器，然后服务器去存储他的上下午以供服务器进行进一步的处理和请求，比如我们需要获得某个用户的信息，我们应该是通过客户端传递userId给服务器，服务器处理好了返回结果给我们，对服务器而言他不知道每次的状态是什么。这样可以使得Web服务不需要维护客户端以前的交互（因为他不知道这个客户端之前干嘛了）</p><h3 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h3><p>&emsp;&emsp;指客户端应该将服务器的响应存储在客户端本身中，如此客户端无需一次又一次的向服务器请求相同的资源。同事服务器响应应该有如何进行缓存的信息，以方便客户端在一段时间内进行缓存响应。如以下服务器应该具备的响应头以便客户端配置缓存</p><table><thead><tr><th>Sr.No.</th><th>Header &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong>Date</strong><br/>资源创建的日期和时间</td></tr><tr><td>2</td><td><strong>Last Modified</strong><br/>资源上次修改的日期和时间</td></tr><tr><td>3</td><td><strong>Cache-Control</strong><br>用于控制缓存的主标记头</td></tr><tr><td>4</td><td><strong>Expires</strong><br/>缓存的到期日期和时间</td></tr><tr><td>5</td><td><strong>Age</strong><br/>从服务器获得资源后的持续时间</td></tr></tbody></table><table><thead><tr><th>Sr.No.</th><th>Directive &amp; Description</th></tr></thead><tbody><tr><td>1</td><td><strong>Public</strong><br/>公共的可缓存资源</td></tr><tr><td>2</td><td><strong>Private</strong><br/>表示资源只可以被客户端和服务器缓存，中介不能缓存的资源</td></tr><tr><td>3</td><td><strong>no-cache/no-store</strong><br/>指资源不可以缓存</td></tr><tr><td>4</td><td><strong>max-age</strong><br/>表示缓存的最长有效期。超过事件后就需要客户端再次请求</td></tr><tr><td>5</td><td><strong>must-revalidate</strong><br/>在超过有效期后，服务器必须重新验证资源</td></tr></tbody></table><h2 id="RESTful传递消息的方式"><a href="#RESTful传递消息的方式" class="headerlink" title="RESTful传递消息的方式"></a>RESTful传递消息的方式</h2><p>&emsp;&emsp;因为REST的无状态限制，HTTP无状态协议和他很契合。客户端通过HTTP请求发送消息，服务器以HTTP形式响应。常见的有四种动作：GET,POST,PUT,DELETE其中要考虑的是：</p><ul><li>GET操作是只读的并且是安全的。</li><li>PUT和DELETE操作是幂等的，这意味着无论调用多少次这些操作，其结果都将始终相同。</li><li>PUT和POST操作几乎相同，不同之处仅在于PUT操作是幂等的，而POST操作可能导致不同的结果<h2 id="关于RESTful架构的寻址要求"><a href="#关于RESTful架构的寻址要求" class="headerlink" title="关于RESTful架构的寻址要求"></a>关于RESTful架构的寻址要求</h2>寻址是指定位服务器上的一个或者多个资源。因为REST架构的每个资源都通过URL来标识，所以关于寻址的URL我们需要考虑以下几点：</li><li>使用复数名词定义<br>例如，我们要访问用户资源应该使用users而不是user</li><li>避免使用空格而使用_或者-代替</li><li>使用小写字母</li><li>保持向后兼容<br>&emsp;&emsp;因为一些Web服务一旦上线，可能需要保证始终可用，一旦我们的资源移动了位置，我们需要通过HTTP的3xx状态告知客户端将就URL重定向新的URL</li><li>使用HTTP动词，URL不包含动词<br>我们使用POST、GET等动词来表示请求方式，之后的URL里的资源应该使用名词来形容，比如我们需要获得User信息，<code>../UserManagement/rest/UserService/getUser/1</code>，其中使用<code>getUser</code>是不太好的，因为使用<code>UserManagement/rest/UserService/users/1</code>，来形容我们的资源。<br>参考自：<a href="https://www.tutorialspoint.com/restful/restful_addressing.htm">restful</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>restful</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SOLID</title>
    <link href="/2020/11/09/SOLID/"/>
    <url>/2020/11/09/SOLID/</url>
    
    <content type="html"><![CDATA[<h2 id="设计模式之SOLID原则"><a href="#设计模式之SOLID原则" class="headerlink" title="设计模式之SOLID原则"></a>设计模式之SOLID原则</h2><p>&emsp;&emsp;SOLID原则是为了让程序员更加轻松的开发出易于维护和拓展的软件，避免代码的冗杂，让我们可以很轻松的重构代码。<code>SOLID</code>原则的五大原则分别为：</p><h2 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle, SRP)"></a>单一职责原则(Single Responsibility Principle, SRP)</h2><p>&emsp;&emsp;<code>SRP</code>简单来说就是解耦，类似于工厂里的分工方式，每个工人只需要做好一件事就可以了（当然现在这个社会其实每个人不能只会一样，不利于个人发展的），对于我们软件中的类来说也是这样的，每个类只需要负责某一方面的职责即可，如此可以方便我们对这些类进行复用，组合。实现高内聚低耦合的设计原则。不过因为将功能进行了较为细致的拆分，所以在需要进行大面积修改时可能会有不小的工作量。</p><h2 id="开闭原则-Open-Closed-Principle-OCP"><a href="#开闭原则-Open-Closed-Principle-OCP" class="headerlink" title="开闭原则(Open-Closed Principle, OCP)"></a>开闭原则(Open-Closed Principle, OCP)</h2><p>对象应该可以进行扩展，但是不能进行修改。软件的需求发生改变后，我们的系统应该保持设计框架的稳定，不能因为一个需求的修改出现大量的更改，当我们的软件符合开闭原则之后，我们可以对某个需要修改的组件对象进行扩展，而不用修改现有的代码，降低了维护成本。</p><h2 id="里氏代换原则-Liskov-Substitution-Principle"><a href="#里氏代换原则-Liskov-Substitution-Principle" class="headerlink" title="里氏代换原则(Liskov Substitution Principle)"></a>里氏代换原则(Liskov Substitution Principle)</h2><p>&emsp;&emsp;里氏替换原则是Liskov提出的关于继承的一些原则。Robert C. Martin简化的说过里氏替换原则就是**<em>Subtypes must be substitutable for their base types**</em>，就是说子类必须能够替换他们的基类。因此我们需要注意以下几点：</p><ul><li>子类必须实现父类的抽象方法，但不得重写（覆盖）父类的非抽象（已实现）方法。</li><li>子类中可以增加自己特有的方法。</li><li>当子类覆盖或实现父类的方法时，方法的前置条件（即方法的形参）要比- 父类方法的输入参数更宽松。(即只能重载不能重写)</li><li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li></ul><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">father</span></span>&#123;  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x, y</span>)</span> &#123;    <span class="hljs-built_in">this</span>.x = x;    <span class="hljs-built_in">this</span>.y = y;  &#125;  <span class="hljs-function"><span class="hljs-title">sum</span>(<span class="hljs-params"></span>)</span> &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x+<span class="hljs-built_in">this</span>.y;  &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">father</span></span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">x,y</span>)</span>&#123;    <span class="hljs-built_in">super</span>(x,y);  &#125;  <span class="hljs-function"><span class="hljs-title">minus</span>(<span class="hljs-params">x,y</span>)</span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x-<span class="hljs-built_in">this</span>.y;  &#125;&#125;<span class="hljs-keyword">let</span> fat = <span class="hljs-keyword">new</span> father(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-keyword">let</span> so = <span class="hljs-keyword">new</span> son(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(fat.sum(),so.sum(),so.minus());<span class="hljs-comment">// 3  3  -1</span><span class="hljs-comment">//父类被子类替换后结果也是一样的</span></code></pre><h2 id="依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle,DIP)"></a>依赖倒置原则(Dependence Inversion Principle,DIP)</h2><p>&emsp;&emsp;实体必须依赖抽象而不依赖具体。高级模块一定不能依赖于低级模块，而应该依赖于抽象。简单来说就是将我们平时的依赖反转，不再是高级模块去依赖低级模块，而是低级模块反向依赖一个抽象类，然后高级模块也依赖于这个抽象类。从而剥离模块之间的关联，达到了解耦的目的。关于这块还有一个IOC控制反转，利用容器将控制权反转，将对象的获得等控制权交给容器，如此来降低耦合。</p><h2 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)"></a>接口隔离原则(Interface Segregation Principle, ISP)</h2><p>&emsp;&emsp;要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br>参考于：<a href="https://www.jianshu.com/p/3268264ae581">更详细的六大设计原则</a></p>]]></content>
    
    
    <categories>
      
      <category>solid</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise三兄弟all,race,allsettled</title>
    <link href="/2020/10/03/promise%E4%B8%89%E5%85%84%E5%BC%9F/"/>
    <url>/2020/10/03/promise%E4%B8%89%E5%85%84%E5%BC%9F/</url>
    
    <content type="html"><![CDATA[<h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p>Promise.all(iterable) 方法返回一个 Promise 实例，此实例在 iterable 参数内所有的 promise 都“完成（resolved）”或参数中不包含 promise 时回调完成（resolve）；如果参数中  promise 有一个失败（rejected），此实例回调失败（reject），失败的原因是第一个失败 promise 的结果。</p><pre><code class="hljs reasonml">const promise1=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-number">1</span>);const promise2=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-number">2</span>);const promise3=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-number">3</span>);const promise4=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-number">4</span>);const promise = <span class="hljs-literal">[<span class="hljs-identifier">promise1</span>,<span class="hljs-identifier">promise2</span>,<span class="hljs-identifier">promise3</span>,<span class="hljs-identifier">promise4</span>]</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>all(promise).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">val</span>=&gt;&#123;    <span class="hljs-keyword">val</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">r</span>=&gt;<span class="hljs-params">console</span>.<span class="hljs-params">log</span>(<span class="hljs-params">r</span>)</span>)&#125;).catch(res=&gt;&#123;    console.log(res)&#125;)<span class="hljs-comment">//3</span></code></pre><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>all的特性是只要有一个<code>rejected</code>就返回该失败结果，其他的都当作没发生。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAll</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> (r,j)=&gt;&#123;    <span class="hljs-keyword">let</span> data = [],Err,isError=<span class="hljs-literal">false</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;        <span class="hljs-keyword">if</span>(isError) <span class="hljs-keyword">break</span>;                promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise);            <span class="hljs-keyword">await</span>   promise.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;            data.push(res);        &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;          isError=<span class="hljs-literal">true</span>;            j(error)        &#125;)        &#125;        r(data);  &#125;)&#125;</code></pre><h2 id="race"><a href="#race" class="headerlink" title="race"></a>race</h2><p>Promise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个promise解决或拒绝，返回的 promise就会解决或拒绝。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise1=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);<span class="hljs-keyword">const</span> promise2=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(reject, <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;500&#x27;</span>);&#125;);<span class="hljs-keyword">const</span> promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;  <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1000&#x27;</span>);&#125;);<span class="hljs-keyword">const</span> promise4=<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">4</span>);<span class="hljs-keyword">const</span> promise = [promise3,promise2,promise1,promise4];<span class="hljs-built_in">Promise</span>.race(promise).then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(value);&#125;);<span class="hljs-comment">// 1 1最快得到结果，所以只会输出1</span></code></pre><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myRace</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">r,j</span>)=&gt;</span>&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;                promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise);            promise.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;            r(res)        &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;            j(error)        &#125;)        &#125;  &#125;)&#125;</code></pre><h2 id="allsettled"><a href="#allsettled" class="headerlink" title="allsettled"></a>allsettled</h2><p>Promise.allSettled()方法返回一个在所有给定的promise都已经fulfilled或rejected后的promise，并带有一个对象数组，每个对象表示对应的promise结果。当有多个彼此不依赖的异步任务成功完成时，或者我们要得到每个promise的结果的时候，可以使用。</p><pre><code class="hljs reasonml">const promise1=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-number">1</span>);const promise2=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-number">2</span>);const promise3=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>reject(<span class="hljs-number">3</span>);const promise4=<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(<span class="hljs-number">4</span>);const promise = <span class="hljs-literal">[<span class="hljs-identifier">promise1</span>,<span class="hljs-identifier">promise2</span>,<span class="hljs-identifier">promise3</span>,<span class="hljs-identifier">promise4</span>]</span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>all<span class="hljs-constructor">Settled(<span class="hljs-params">promise</span>)</span>.<span class="hljs-keyword">then</span>(<span class="hljs-keyword">val</span>=&gt;&#123;    <span class="hljs-keyword">val</span>.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">re</span>=&gt;<span class="hljs-params">console</span>.<span class="hljs-params">log</span>(<span class="hljs-params">re</span>)</span>)&#125;)<span class="hljs-comment">//&gt; Object &#123; status: &quot;fulfilled&quot;, value: 1 &#125;</span><span class="hljs-comment">//&gt; Object &#123; status: &quot;fulfilled&quot;, value: 2 &#125;</span><span class="hljs-comment">//&gt; Object &#123; status: &quot;rejected&quot;, reason: 3 &#125;</span><span class="hljs-comment">//&gt; Object &#123; status: &quot;fulfilled&quot;, value: 4 &#125;</span></code></pre><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><p>根据其特性，不难实现allSettled，我们只需要得到所有的promise结果存到数组返回即可。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myAllSettled</span>(<span class="hljs-params">promises</span>)</span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-keyword">async</span> resolve=&gt;&#123;    <span class="hljs-keyword">let</span> data=[];    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> promise <span class="hljs-keyword">of</span> promises)&#123;      promise = promise <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span> ? promise : <span class="hljs-built_in">Promise</span>.resolve(promise)        <span class="hljs-keyword">await</span> promise.then(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;        data.push(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;fulfilled&#x27;</span>, <span class="hljs-attr">value</span>: res &#125;);      &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;        data.push(&#123; <span class="hljs-attr">status</span>: <span class="hljs-string">&#x27;rejected&#x27;</span>, <span class="hljs-attr">reason</span>: error &#125;);      &#125;)    &#125;    resolve(data);  &#125;)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>手写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手写汇总</title>
    <link href="/2020/10/03/%E6%89%8B%E5%86%99/"/>
    <url>/2020/10/03/%E6%89%8B%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h1 id="一些手写的内容汇总"><a href="#一些手写的内容汇总" class="headerlink" title="一些手写的内容汇总"></a>一些手写的内容汇总</h1><h2 id="1、通过XMLHttpRequest实现网络请求"><a href="#1、通过XMLHttpRequest实现网络请求" class="headerlink" title="1、通过XMLHttpRequest实现网络请求"></a>1、通过XMLHttpRequest实现网络请求</h2><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>,url,<span class="hljs-literal">true</span>)<span class="hljs-comment">//异步，false同步</span>xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">if</span>(xhr.readyState==<span class="hljs-number">4</span>&amp;&amp;xhr.state==<span class="hljs-number">200</span>)    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;成功&#x27;</span>)  <span class="hljs-keyword">else</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;失败&#x27;</span>)&#125;xhr.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;连接失败&#x27;</span>,e)&#125;xhr.send();</code></pre><h2 id="2、手写call-apply-bind"><a href="#2、手写call-apply-bind" class="headerlink" title="2、手写call(),apply(),bind()"></a>2、手写call(),apply(),bind()</h2><p>之前探讨了这三种函数的区别，正好理解的还算可以，所以试一试写出三种函数的手写代码。</p><h3 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h3><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg</span>)</span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能被call&#x27;</span>);    &#125;  <span class="hljs-comment">//如果传入的是null或者undefined 或者空则绑定为全局</span>    <span class="hljs-keyword">let</span> thisArg = thisArg || <span class="hljs-built_in">window</span>;  <span class="hljs-comment">//在传入的对象上创建方法并赋给它</span>  thisArg.fn = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">let</span> args = [];  <span class="hljs-comment">//把参数拿出来，从第二个拿，第一个是指定的this</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt; <span class="hljs-built_in">arguments</span>.length; i++)&#123;    args.push(<span class="hljs-string">`arguments[<span class="hljs-subst">$&#123;i&#125;</span>]`</span>)  &#125;  <span class="hljs-comment">//把参数传入对象的方法执行，得到结果</span>  <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">`context.fn(<span class="hljs-subst">$&#123;args&#125;</span>)`</span>);  <span class="hljs-comment">//删除方法</span>  <span class="hljs-keyword">delete</span> thisArg.fn;  <span class="hljs-comment">//返回结果</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h3><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.apply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,arr</span>)</span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能被apply&#x27;</span>);    &#125;  <span class="hljs-comment">//如果传入的是null或者undefined 或者空则绑定为全局</span>    <span class="hljs-keyword">let</span> thisArg = <span class="hljs-built_in">Object</span>(thisArg) || <span class="hljs-built_in">window</span>;  <span class="hljs-comment">//在传入的对象上创建方法并赋给它</span>  thisArg.fn = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> result;  <span class="hljs-comment">//如果arr没有，就直接执行</span>  <span class="hljs-keyword">if</span>(!arr)&#123;    result = thisArg.fn();  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-comment">//如果有参数就一一取出来给方法执行</span>    <span class="hljs-keyword">let</span> args = [];    <span class="hljs-comment">//把参数拿出来，从第二个拿，第一个是指定的this</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt; arr.length; i++)&#123;      args.push(<span class="hljs-string">`arguments[<span class="hljs-subst">$&#123;i&#125;</span>]`</span>)    &#125;    <span class="hljs-comment">//把参数传入对象的方法执行，得到结果</span>    <span class="hljs-keyword">let</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">`context.fn(<span class="hljs-subst">$&#123;args&#125;</span>)`</span>);   &#125;  <span class="hljs-comment">//删除方法</span>  <span class="hljs-keyword">delete</span> thisArg.fn;  <span class="hljs-comment">//返回结果</span>  <span class="hljs-keyword">return</span> result;&#125;</code></pre><h3 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h3><p>以上两种都好写，但是bind()因为要返回一个新的函数，然后还可以被new出来，new之后this指向新创建的new实例。</p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">otherThis</span>) </span>&#123;   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能被bind&#x27;</span>);   &#125;  <span class="hljs-comment">//把第一个参数后面的参数拿出来</span>   <span class="hljs-keyword">var</span> baseArgs= <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>),       baseArgsLength = baseArgs.length,       fToBind = <span class="hljs-built_in">this</span>,       fNOP    = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;,       fBound  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;         baseArgs.length = baseArgsLength; <span class="hljs-comment">// reset to default base arguments</span>         baseArgs.push.apply(baseArgs, <span class="hljs-built_in">arguments</span>);         <span class="hljs-keyword">return</span> fToBind.apply(                fNOP.prototype.isPrototypeOf(<span class="hljs-built_in">this</span>) ? <span class="hljs-built_in">this</span> : otherThis, baseArgs         );       &#125;;   <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.prototype) &#123;     <span class="hljs-comment">// Function.prototype doesn&#x27;t have a prototype property</span>     fNOP.prototype = <span class="hljs-built_in">this</span>.prototype;    &#125;   fBound.prototype = <span class="hljs-keyword">new</span> fNOP();   <span class="hljs-keyword">return</span> fBound; &#125;;</code></pre><p>以上代码是mdn上的代码，但是和原本的bind函数还是有很大差别。以下是一个较为完整的方案。</p><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.bind = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span>(<span class="hljs-params">that</span>) </span>&#123;    <span class="hljs-keyword">var</span> target = <span class="hljs-built_in">this</span>;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;function&#x27;</span> || toStr.call(target) !== funcType) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(ERROR_MESSAGE + target);    &#125;    <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>);    <span class="hljs-keyword">var</span> bound;    <span class="hljs-keyword">var</span> binder = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> bound) &#123;            <span class="hljs-keyword">var</span> result = target.apply(                <span class="hljs-built_in">this</span>,                args.concat(slice.call(<span class="hljs-built_in">arguments</span>))            );            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>(result) === result) &#123;                <span class="hljs-keyword">return</span> result;            &#125;            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">return</span> target.apply(                that,                args.concat(slice.call(<span class="hljs-built_in">arguments</span>))            );        &#125;    &#125;;    <span class="hljs-keyword">var</span> boundLength = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, target.length - args.length);    <span class="hljs-keyword">var</span> boundArgs = [];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; boundLength; i++) &#123;        boundArgs.push(<span class="hljs-string">&#x27;$&#x27;</span> + i);    &#125;    bound = <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;binder&#x27;</span>, <span class="hljs-string">&#x27;return function (&#x27;</span> + boundArgs.join(<span class="hljs-string">&#x27;,&#x27;</span>) + <span class="hljs-string">&#x27;)&#123; return binder.apply(this,arguments); &#125;&#x27;</span>)(binder);    <span class="hljs-keyword">if</span> (target.prototype) &#123;        <span class="hljs-keyword">var</span> Empty = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Empty</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;        Empty.prototype = target.prototype;        bound.prototype = <span class="hljs-keyword">new</span> Empty();        Empty.prototype = <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-keyword">return</span> bound;&#125;;</code></pre><h2 id="3、手写数组深拷贝"><a href="#3、手写数组深拷贝" class="headerlink" title="3、手写数组深拷贝"></a>3、手写数组深拷贝</h2><p>深拷贝，主要是要对深层次的内容进行拷贝，拷贝到新的地址里。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">obj</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj!=<span class="hljs-string">&#x27;object&#x27;</span> || obj ==<span class="hljs-literal">null</span>)&#123;    <span class="hljs-keyword">return</span> obj  &#125;  <span class="hljs-keyword">let</span> result;  <span class="hljs-keyword">if</span>(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)&#123;    result = []  &#125;<span class="hljs-keyword">else</span>&#123;    result = &#123;&#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> obj)&#123;    <span class="hljs-keyword">if</span>(obj.hasOwnProperty(key))&#123;        result[key]=deepClone(obj[key])    &#125;  &#125;  <span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">let</span> test = &#123;  aa:<span class="hljs-number">12</span>,  bb:<span class="hljs-string">&#x27;string&#x27;</span>,  cc:[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>],  dd:&#123;    ab:<span class="hljs-number">123</span>,    ac:<span class="hljs-string">&#x27;array&#x27;</span>,    bc:[<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&#x27;3&#x27;</span>]  &#125;&#125;test.__proto__.gg=<span class="hljs-number">123</span>;deepClone(test)==test       <span class="hljs-comment">//false</span><span class="hljs-keyword">let</span> tt = test;tt==test;                                   <span class="hljs-comment">//true</span></code></pre><h2 id="3、柯里化函数的实现"><a href="#3、柯里化函数的实现" class="headerlink" title="3、柯里化函数的实现"></a>3、柯里化函数的实现</h2><p>柯里化就是将多参数转换成单一参数的函数，要实现参数的分解，我们主要使用bind()来分解参数。</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">currying</span><span class="hljs-params">(fn,length)</span></span>&#123;length=length||fn.length;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span></span>&#123;    <span class="hljs-keyword">return</span> args.length &gt;= length ?       fn.apply(<span class="hljs-keyword">this</span>,args):    currying(fn.bind(<span class="hljs-keyword">this</span>,...args),length-args.length);  &#125;&#125;</code></pre><p><img src="https://cdn.jsdelivr.net/gh/StevenT1/myImages/img/image.png" alt="代码实例"></p><h2 id="4、手写EventEmitter"><a href="#4、手写EventEmitter" class="headerlink" title="4、手写EventEmitter"></a>4、手写EventEmitter</h2><p>遇到这么个题目，嗯，题目，某人让我写一下，就写一下吧，照着文档算是能够实现一些功能了，但是有挺多要求没有实现的，但起码还是能达到一定要求的。<br>events（事件触发器）是nodejs中的提供事件触发的模块，events提供了类EventEmitter，EventEmitter 的核心就是事件触发与事件监听器功能的封装。提供了很多方法来进行监听器的绑定移除，这里我就只写其中几个简单的（主要是好实现，而且懒得做多了）。</p><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitterOfme</span> </span>&#123;    <span class="hljs-keyword">constructor</span>() &#123;        <span class="hljs-keyword">this</span>.MaxListeners = <span class="hljs-number">10</span>;        <span class="hljs-keyword">this</span>.currentListeners = <span class="hljs-number">0</span>;        <span class="hljs-keyword">this</span>.events = [];    &#125;    <span class="hljs-comment">//为指定事件添加一个监听器到监听器数组的尾部。</span>    addListener(event, listener) &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event]) &#123;            console.log(<span class="hljs-string">&#x27;没有此监听器&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.events[event].push(listener);        &#125;    &#125;    <span class="hljs-comment">//为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。</span>    on(event, listener) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.currentListeners + <span class="hljs-number">1</span> &gt; <span class="hljs-keyword">this</span>.MaxListeners) &#123;            console.log(<span class="hljs-string">&#x27;超过监听器上限&#x27;</span>)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event]) &#123;                <span class="hljs-keyword">this</span>.currentListeners++;                <span class="hljs-keyword">this</span>.events[event] = [listener];            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">this</span>.events[event].push(listener);            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。</span>    once(event, listener) &#123;        let fn = (arg) =&gt; &#123;            listener(arg);            <span class="hljs-keyword">this</span>.removeListener(event, fn);        &#125;        <span class="hljs-keyword">this</span>.on(event, fn);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。</span>    <span class="hljs-comment">//它接受两个参数，第一个是事件名称，第二个是回调函数名称。</span>    removeListener(event, listener) &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event]) &#123;            console.log(`不存在$&#123;event&#125;监听器`)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.events[event].splice(<span class="hljs-keyword">this</span>.events[event].lastIndexOf(listener),<span class="hljs-number">1</span>);        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</span>    removeAllListeners(events) &#123;        <span class="hljs-keyword">if</span> (events === undefined) &#123;            <span class="hljs-keyword">this</span>.events = [];            <span class="hljs-keyword">this</span>.currentListeners = <span class="hljs-number">0</span>;        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">for</span>(let key of events) &#123;                delete <span class="hljs-keyword">this</span>.events[key];                <span class="hljs-keyword">this</span>.currentListeners--;            &#125;        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</span>    setMaxListeners(n) &#123;        <span class="hljs-keyword">this</span>.MaxListeners = n;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;    &#125;    <span class="hljs-comment">//返回指定事件的监听器数组。</span>    listeners(event) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.events[event]    &#125;    allListeners() &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.events;    &#125;    <span class="hljs-comment">//按监听器的顺序执行执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</span>    emit(event, ...args) &#123;        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.events[event])            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">this</span>.events[event].forEach((<span class="hljs-function"><span class="hljs-keyword">fun</span>, index) =&gt; <span class="hljs-keyword">fun</span>.<span class="hljs-title">call</span><span class="hljs-params">(this, args[index])</span></span>)            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;        &#125;    &#125;&#125;</code></pre><h2 id="5、实现防抖函数"><a href="#5、实现防抖函数" class="headerlink" title="5、实现防抖函数"></a>5、实现防抖函数</h2><p>防抖的非立即执行版本就是在触发一次后的固定时间内，一直不会执行操作，如果在固定时间内触发了，则重新计时，如果一直没触发，则等到固定时间到了执行.</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thro</span>(<span class="hljs-params">fn,wait</span>)</span>&#123;    <span class="hljs-keyword">let</span> timer;  <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> agrs = <span class="hljs-built_in">arguments</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        <span class="hljs-built_in">clearTimeout</span>(timer);        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        fn.apply(_that,agrs);      &#125;,wait)  &#125;&#125;</code></pre><p>防抖的立即执行版本</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thro</span>(<span class="hljs-params">fn,wait,rightNow</span>)</span>&#123;    <span class="hljs-keyword">let</span> timer;  <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> agrs = <span class="hljs-built_in">arguments</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-comment">//进去先把计时器清除</span>    <span class="hljs-keyword">if</span>(timer) <span class="hljs-built_in">clearTimeout</span>(timer);    <span class="hljs-comment">//在这里判断是不是第一次运行，是就立刻执行，不是就只需要执行计时器就行</span>    <span class="hljs-keyword">const</span> im = !timer;    <span class="hljs-keyword">if</span>(rightNow)&#123;        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        timer = <span class="hljs-literal">null</span>;      &#125;,wait);      <span class="hljs-keyword">if</span>(im) fn.apply(_that,agrs);    &#125;<span class="hljs-keyword">else</span>&#123;        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;        fn.apply(_that,agrs);      &#125;,wait)    &#125;  &#125;&#125;</code></pre><h2 id="6、节流函数"><a href="#6、节流函数" class="headerlink" title="6、节流函数"></a>6、节流函数</h2><p>节流函数就是在规定时间内只执行一次操作，触发多少次都只会执行一次。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">thro</span>(<span class="hljs-params">fn,wait</span>)</span>&#123;<span class="hljs-keyword">let</span> timer;  <span class="hljs-keyword">let</span> _that = <span class="hljs-built_in">this</span>;  <span class="hljs-keyword">let</span> agrs = <span class="hljs-built_in">arguments</span>;  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">if</span>(!timer)&#123;    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;      fn.apply(_that,agrs);        timer = <span class="hljs-literal">null</span>;      &#125;,wait)    &#125;  &#125;&#125;</code></pre><h2 id="7、手写flat-扁平化"><a href="#7、手写flat-扁平化" class="headerlink" title="7、手写flat()扁平化"></a>7、手写flat()扁平化</h2><p>一般是对数组实现扁平化，这里我们可以用到apply和concat的组合，因为apply会把数组参数拆解，所以正好符合我们拍扁数组的需求</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flat</span>(<span class="hljs-params">arrs</span>)</span>&#123;  <span class="hljs-keyword">const</span> isDeep = arrs.some(<span class="hljs-function"><span class="hljs-params">arr</span>=&gt;</span>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)  <span class="hljs-keyword">if</span>(!isDeep)&#123;    <span class="hljs-keyword">return</span> arrs  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> flat(<span class="hljs-built_in">Array</span>.prototype.concat.apply([],arrs))  &#125;&#125;flat([<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]) <span class="hljs-comment">//[1, 2, 2, 3, 3, 4, 5]</span></code></pre><h2 id="8、instanceof的实现"><a href="#8、instanceof的实现" class="headerlink" title="8、instanceof的实现"></a>8、instanceof的实现</h2><p>instanceof是通过判断其原型链上的属性是否在目标对象的原型链上也有，所以只需要对比prototype就行了。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myInstanceof</span>(<span class="hljs-params">obj,resouceObj</span>)</span>&#123;  <span class="hljs-keyword">let</span> objProto = obj.__proto__;  <span class="hljs-keyword">let</span> resouceProto = resouceObj.prototype  <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;    <span class="hljs-keyword">if</span>(objProto === <span class="hljs-literal">null</span>)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>    &#125;    <span class="hljs-keyword">if</span>(objProto === resouceProto)&#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>    &#125;    objProto = objProto.__proto__  &#125;&#125;</code></pre><h2 id="9、手写继承"><a href="#9、手写继承" class="headerlink" title="9、手写继承"></a>9、手写继承</h2><p>JavaScript的继承虽然有class可以用extends来继承，但是如果需要我们使用原型链进行继承，我们就需要自己来实现了。<br>需要实现继承，需要我们把父类的原型链和静态属性继承到子类中，所以代码如下：</p><pre><code class="hljs javascript"><span class="hljs-comment">//父类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parents</span>(<span class="hljs-params">name</span>)</span>&#123;    <span class="hljs-built_in">this</span>.name = name;&#125;<span class="hljs-comment">//父类原型链上的方法</span>Parents.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)&#125;<span class="hljs-comment">//父类的静态方法</span>Parents.family = <span class="hljs-string">&#x27;Bob&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child</span>(<span class="hljs-params">age</span>)</span>&#123;  <span class="hljs-comment">//继承父类的属性</span>    Parents.call(<span class="hljs-built_in">this</span>);&#125;<span class="hljs-comment">//把父类的原型链拷贝一个进来，同时把构造函数修正为自己的构造函数，并且不能被修改</span>child.prototype = <span class="hljs-built_in">Object</span>.create(Parents.prototype,&#123;    <span class="hljs-title">constructor</span>:&#123;    value:<span class="hljs-keyword">new</span> child(),    writeable:<span class="hljs-literal">false</span>  &#125;&#125;);<span class="hljs-comment">//获取父类的静态属性</span><span class="hljs-keyword">let</span> keys = <span class="hljs-built_in">Object</span>.entries(Parents);<span class="hljs-comment">//把静态属性放进子类</span><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i&lt;keys.length;i++)&#123;    <span class="hljs-keyword">let</span> key = keys[i][<span class="hljs-number">0</span>];  <span class="hljs-keyword">let</span> value = keys[i][<span class="hljs-number">1</span>];  child[key] = value;&#125;<span class="hljs-keyword">new</span> child();</code></pre><h2 id="10、手写new方法"><a href="#10、手写new方法" class="headerlink" title="10、手写new方法"></a>10、手写new方法</h2><p>new操作符做了哪些事情？</p><ul><li><p>创建一个新的对象</p></li><li><p>新对象会被执行[[Prototype]]连接，关联到构造函数的.prototype对象上</p></li><li><p>新对象会绑定到函数调用的this</p></li><li><p>如果函数没有返回其他对象，那么new表达式中的函数会调用自动返回这个新对象</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeNew</span>(<span class="hljs-params">fun</span>)</span>&#123;    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> fun !== <span class="hljs-string">&quot;Object&quot;</span>)&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();  &#125;  <span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);  <span class="hljs-comment">//设置对象的原型（即内部 [[Prototype]] 属性）。</span>  <span class="hljs-built_in">Object</span>.setPrototypeof(obj,fun.prototype);  <span class="hljs-keyword">let</span> result = fun.apply(obj,<span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">1</span>));  <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> result == <span class="hljs-string">&quot;Object&quot;</span> || (<span class="hljs-keyword">typeof</span> result ==<span class="hljs-string">&quot;Function&quot;</span> &amp;&amp; result !==<span class="hljs-literal">null</span>))&#123;    <span class="hljs-keyword">return</span> result  &#125;<span class="hljs-keyword">else</span>&#123;    <span class="hljs-keyword">return</span> obj;  &#125;&#125;</code></pre><h2 id="11、手写Object-create方法"><a href="#11、手写Object-create方法" class="headerlink" title="11、手写Object.create方法"></a>11、手写Object.create方法</h2><p>要实现create方法，我们需要知道create有哪些属性</p><p>Object.create(proto,ptopertiesObject)</p><ul><li>使用指定的proto对象和属性创建一个新的对象</li><li>ptopertiesObject表示给新创建的对象的属性进行设置</li><li>如果ptopertiesObject是null或者不是对象，就会抛出异常</li></ul></li></ul><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">proto,propertiesObject</span>)</span>&#123;<span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> propertiesObject !== <span class="hljs-string">&quot;object&quot;</span>)&#123;  <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();  &#125;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">temp</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;  <span class="hljs-comment">//挂上原型链</span>  temp.prototype = proto;  <span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> temp();  <span class="hljs-keyword">if</span>(propertiesObject !== <span class="hljs-literal">undefined</span>)&#123;  <span class="hljs-keyword">if</span>(propertiesObject!==<span class="hljs-built_in">Object</span>(propertiesObject))&#123;    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">TypeError</span>();    &#125;    <span class="hljs-built_in">Object</span>.defineProperties(o,propertiesObject);  &#125;  <span class="hljs-keyword">return</span> o;&#125;</code></pre><h2 id="12、手写Promise方法"><a href="#12、手写Promise方法" class="headerlink" title="12、手写Promise方法"></a>12、手写Promise方法</h2><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPromise</span> </span>&#123;    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">exector</span>)</span> &#123;      <span class="hljs-built_in">this</span>.status = MyPromise.PENDING;      <span class="hljs-comment">// 1.3 “value” is any legal JavaScript value (including undefined, a thenable, or a promise).</span>      <span class="hljs-built_in">this</span>.value = <span class="hljs-literal">null</span>;      <span class="hljs-comment">// 1.5 “reason” is a value that indicates why a promise was rejected.</span>      <span class="hljs-built_in">this</span>.reason = <span class="hljs-literal">null</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">       * 2.2.6 then may be called multiple times on the same promise</span><span class="hljs-comment">       *  2.2.6.1 If/when promise is fulfilled, all respective onFulfilled callbacks must execute in the order of their originating calls to then</span><span class="hljs-comment">       *  2.2.6.2 If/when promise is rejected, all respective onRejected callbacks must execute in the order of their originating calls to then.</span><span class="hljs-comment">       */</span>        <span class="hljs-built_in">this</span>.onFulfilledCallback = [];      <span class="hljs-built_in">this</span>.onRejectedCallback = [];      <span class="hljs-built_in">this</span>.initBind();      <span class="hljs-built_in">this</span>.init(exector);    &#125;    <span class="hljs-function"><span class="hljs-title">initBind</span>(<span class="hljs-params"></span>)</span> &#123;      <span class="hljs-comment">// 绑定 this</span>      <span class="hljs-comment">// 因为 resolve 和 reject 会在 exector 作用域中执行，因此这里需要将 this 绑定到当前的实例</span>      <span class="hljs-built_in">this</span>.resolve = <span class="hljs-built_in">this</span>.resolve.bind(<span class="hljs-built_in">this</span>);      <span class="hljs-built_in">this</span>.reject = <span class="hljs-built_in">this</span>.reject.bind(<span class="hljs-built_in">this</span>);    &#125;    <span class="hljs-function"><span class="hljs-title">init</span>(<span class="hljs-params">exector</span>)</span> &#123;      <span class="hljs-keyword">try</span> &#123;        exector(<span class="hljs-built_in">this</span>.resolve, <span class="hljs-built_in">this</span>.reject);      &#125; <span class="hljs-keyword">catch</span> (err) &#123;        <span class="hljs-built_in">this</span>.reject(err);      &#125;    &#125;      <span class="hljs-function"><span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>)</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.PENDING) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">this</span>.status = MyPromise.FULFILLED;          <span class="hljs-built_in">this</span>.value = value;          <span class="hljs-built_in">this</span>.onFulfilledCallback.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-built_in">this</span>.value));        &#125;)      &#125;    &#125;      <span class="hljs-function"><span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>)</span> &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.PENDING) &#123;        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;          <span class="hljs-built_in">this</span>.status = MyPromise.REJECTED;          <span class="hljs-built_in">this</span>.reason = reason;          <span class="hljs-built_in">this</span>.onRejectedCallback.forEach(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> cb(<span class="hljs-built_in">this</span>.reason));        &#125;)      &#125;    &#125;      <span class="hljs-function"><span class="hljs-title">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>)</span> &#123;      onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">&quot;function&quot;</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value      onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;      <span class="hljs-keyword">let</span> promise2;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.FULFILLED) &#123;        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onFulfilled(<span class="hljs-built_in">this</span>.value);              MyPromise.resolvePromise(promise2,x,resolve,reject);            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)        &#125;)      &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.REJECTED) &#123;        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;          <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onRejected(<span class="hljs-built_in">this</span>.reason)              MyPromise.resolvePromise(promise2,x,resolve,reject)            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)        &#125;)      &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.status === MyPromise.PENDING) &#123;        <span class="hljs-keyword">return</span> promise2 = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;          <span class="hljs-comment">// 向对了中装入 onFulfilled 和 onRejected 函数</span>          <span class="hljs-built_in">this</span>.onFulfilledCallback.push(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onFulfilled(value)              MyPromise.resolvePromise(promise2,x,resolve,reject)            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)            <span class="hljs-built_in">this</span>.onRejectedCallback.push(<span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;            <span class="hljs-keyword">try</span>&#123;              <span class="hljs-keyword">const</span> x = onRejected(reason)              MyPromise.resolvePromise(promise2,x,resolve,reject)            &#125;<span class="hljs-keyword">catch</span>(e)&#123;              reject(e)            &#125;          &#125;)        &#125;)      &#125;    &#125;  &#125;    <span class="hljs-comment">// 2.1 A promise must be in one of three states: pending, fulfilled, or rejected.</span>  MyPromise.PENDING = <span class="hljs-string">&quot;pending&quot;</span>  MyPromise.FULFILLED = <span class="hljs-string">&quot;fulfilled&quot;</span>  MyPromise.REJECTED = <span class="hljs-string">&quot;rejected&quot;</span>    MyPromise.resolvePromise = <span class="hljs-function">(<span class="hljs-params">promise2,x,resolve,reject</span>) =&gt;</span> &#123;    <span class="hljs-keyword">let</span> called = <span class="hljs-literal">false</span>;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 2.3.1 If promise and x refer to the same object, reject promise with a TypeError as the reason.</span><span class="hljs-comment">     */</span>    <span class="hljs-keyword">if</span>(promise2 === x)&#123;      <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&quot;cannot return the same promise object from onfulfilled or on rejected callback.&quot;</span>))    &#125;        <span class="hljs-keyword">if</span>(x <span class="hljs-keyword">instanceof</span> MyPromise)&#123;      <span class="hljs-comment">// 处理返回值是 Promise 对象的情况</span>      <span class="hljs-comment">/**</span><span class="hljs-comment">       * new MyPromise(resolve =&gt; &#123;</span><span class="hljs-comment">       *  resolve(&quot;Success&quot;)</span><span class="hljs-comment">       * &#125;).then(data =&gt; &#123;</span><span class="hljs-comment">       *  return new MyPromise(resolve =&gt; &#123;</span><span class="hljs-comment">       *    resolve(&quot;Success2&quot;)</span><span class="hljs-comment">       *  &#125;)</span><span class="hljs-comment">       * &#125;)</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">if</span>(x.status === MyPromise.PENDING)&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.3.2.1 If x is pending, promise must remain pending until x is fulfilled or rejected.</span><span class="hljs-comment">         */</span>        x.then(<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;          <span class="hljs-comment">// 用 x 的 fulfilled 后的 value 值 y，去设置 promise2 的状态</span>          <span class="hljs-comment">// 上面的注视，展示了返回 Promise 对象的情况，这里调用 then 方法的原因</span>          <span class="hljs-comment">// 就是通过参数 y 或者 reason，获取到 x 中的 value/reason</span>            <span class="hljs-comment">// 拿到 y 的值后，使用 y 的值来改变 promise2 的状态</span>          <span class="hljs-comment">// 依照上例，上面生成的 Promise 对象，其 value 应该是 Success2</span>            <span class="hljs-comment">// 这个 y 值，也有可能是新的 Promise，因此要递归的进行解析，例如下面这种情况</span>            <span class="hljs-comment">/**</span><span class="hljs-comment">           * new Promise(resolve =&gt; &#123;</span><span class="hljs-comment">           *  resolve(&quot;Success&quot;)</span><span class="hljs-comment">           * &#125;).then(data =&gt; &#123;</span><span class="hljs-comment">           *  return new Promise(resolve =&gt; &#123;</span><span class="hljs-comment">           *    resolve(new Promise(resolve =&gt; &#123;</span><span class="hljs-comment">           *      resolve(&quot;Success3&quot;)</span><span class="hljs-comment">           *    &#125;))</span><span class="hljs-comment">           *  &#125;)</span><span class="hljs-comment">           * &#125;).then(data =&gt; console.log(data))</span><span class="hljs-comment">           */</span>            MyPromise.resolvePromise(promise2, y, resolve, reject)        &#125;,<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;          reject(reason)        &#125;)      &#125;<span class="hljs-keyword">else</span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.3 If x is a thenable, it attempts to make promise adopt the state of x, </span><span class="hljs-comment">         * under the assumption that x behaves at least somewhat like a promise. </span><span class="hljs-comment">         * </span><span class="hljs-comment">         * 2.3.2 If x is a promise, adopt its state [3.4]:</span><span class="hljs-comment">         * 2.3.2.2 If/when x is fulfilled, fulfill promise with the same value.</span><span class="hljs-comment">         * 2.3.2.4 If/when x is rejected, reject promise with the same reason.</span><span class="hljs-comment">         */</span>        x.then(resolve,reject)      &#125;      <span class="hljs-comment">/**</span><span class="hljs-comment">       * 2.3.3 Otherwise, if x is an object or function,</span><span class="hljs-comment">       */</span>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((x !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;object&quot;</span>) || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&quot;function&quot;</span>)&#123;      <span class="hljs-comment">/**</span><span class="hljs-comment">       * 2.3.3.1 Let then be x.then. </span><span class="hljs-comment">       * 2.3.3.2 If retrieving the property x.then results in a thrown exception e, reject promise with e as the reason.</span><span class="hljs-comment">       */</span>      <span class="hljs-keyword">try</span>&#123;        <span class="hljs-comment">// then 方法可能设置了访问限制（setter），因此这里进行了错误捕获处理</span>        <span class="hljs-keyword">const</span> then = x.then;        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&quot;function&quot;</span>)&#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">           * 2.3.3.2 If retrieving the property x.then results in a thrown exception e, </span><span class="hljs-comment">           * reject promise with e as the reason.</span><span class="hljs-comment">           */</span>            <span class="hljs-comment">/**</span><span class="hljs-comment">           * 2.3.3.3.1 If/when resolvePromise is called with a value y, run [[Resolve]](promise, y).</span><span class="hljs-comment">           * 2.3.3.3.2 If/when rejectPromise is called with a reason r, reject promise with r.</span><span class="hljs-comment">           */</span>                    then.call(x,<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;            <span class="hljs-comment">/**</span><span class="hljs-comment">             * If both resolvePromise and rejectPromise are called, </span><span class="hljs-comment">             * or multiple calls to the same argument are made, </span><span class="hljs-comment">             * the first call takes precedence, and any further calls are ignored.</span><span class="hljs-comment">             */</span>            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;            called = <span class="hljs-literal">true</span>;            MyPromise.resolvePromise(promise2, y, resolve, reject)                    &#125;,<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> &#123;            <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;            called = <span class="hljs-literal">true</span>;            reject(r);          &#125;)        &#125;<span class="hljs-keyword">else</span>&#123;          resolve(x)        &#125;      &#125;<span class="hljs-keyword">catch</span>(e)&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2.3.3.3.4 If calling then throws an exception e,</span><span class="hljs-comment">         * 2.3.3.3.4.1 If resolvePromise or rejectPromise have been called, ignore it.</span><span class="hljs-comment">         * 2.3.3.3.4.2 Otherwise, reject promise with e as the reason.</span><span class="hljs-comment">         */</span>          <span class="hljs-keyword">if</span>(called) <span class="hljs-keyword">return</span>;        called = <span class="hljs-literal">true</span>;        reject(e)      &#125;    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// If x is not an object or function, fulfill promise with x.</span>      resolve(x);    &#125;  &#125;    MyPromise.deferred  = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">const</span> defer = &#123;&#125;    defer.promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;      defer.resolve = resolve      defer.reject = reject    &#125;)    <span class="hljs-keyword">return</span> defer  &#125;    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-built_in">module</span>.exports = MyPromise  &#125; <span class="hljs-keyword">catch</span> (e) &#123;  &#125;</code></pre><h1 id="13、setInterval"><a href="#13、setInterval" class="headerlink" title="13、setInterval"></a>13、setInterval</h1><ul><li>setInterval() 方法可按照指定的周期（以毫秒计）来调用函数或计算表达式</li><li>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。</li><li>由 setInterval() 返回的 ID 值可用作clearInterval()方法的参数。</li></ul><p>&emsp;&emsp;要实现这个函数，可以通过setTimeout()来实现，我们也可以修改实现的效果，比如说按照叠加的周期进行输出。实现过程很简单：</p><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span>在外面定义一个timer标记我们的定时器，到时候可以关掉let timer = <span class="hljs-literal">null</span>;function mySetInterVal(fn, a, b) &#123;    <span class="hljs-keyword">return</span> &#123;        start: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                fn();                timer ? mySetInterVal(fn, a, b + b).start() : <span class="hljs-literal">null</span>;            &#125;, a + b)        &#125;,        end: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-built_in">clearTimeout</span>(timer);            timer = <span class="hljs-literal">null</span>;        &#125;    &#125;&#125;mySetInterVal(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>),<span class="hljs-number">500</span>,<span class="hljs-number">500</span>&#125;).start();          <span class="hljs-regexp">//</span>开始mySetInterVal(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>),<span class="hljs-number">500</span>,<span class="hljs-number">500</span>&#125;).end();                <span class="hljs-regexp">//</span>结束</code></pre>]]></content>
    
    
    <categories>
      
      <category>手写</category>
      
    </categories>
    
    
    <tags>
      
      <tag>手写系列</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
