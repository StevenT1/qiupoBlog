---
title: 项目经历
author: Taoqiupo
date: 2022-02-21 12:38:38
hide: true
tags: 
category:
index_img:
---
我在解决A问题的时候，预研过X方案和Y方案。基于B理由我选择了X方案，在这过程中我发现X方案存在C问题，于是去研究了X方案源码，找到了问题核心并学习了其思想原理。于是我根据自身的研究解决了这个问题，后续写了篇E文档发布在F平台上，并给原开发团队提了一个PR以推进解决此问题。
### 1. 灵活屏窗口问题
发现多窗口灵活屏存在管理混乱，多开窗口后打开运行速度变慢，数据之间隔离，打开窗口后首屏存在白屏的问题。基于以上问题，想到了几个方案：
+ 借助预设的热点信息（开窗时间或别的），对热点屏进行缓存，关闭即是隐藏，其他窗口都通过正常的打开方式进行打开，关闭即销毁
+ 提供统一的窗口类，使用该窗口类对窗口进行生成和销毁操作，在内部使用LRU淘汰算法对窗口进行统一管理，借助LRU的最近最少使用原则，将非热点窗口淘汰，维持自定义窗口数量的窗口，实现热点窗口的缓存状态，秒开热点窗口。在初次打开或者打开已淘汰的窗口时，通过窗口类中借助BrowserView生成预设或者自定义的骨架屏来替代白屏，在app show到ready-to-show的过程中代替显示。同时构建一个中间层利用ipc通信的方式实现管理的窗口间可以互相通信，渲染进程发送ipc进入主进程中的窗口管理类，窗口管理通过配置的信息对数据进行广播或者对单个渲染窗口发送ipc信息，并管理数据
    对比发现，2号方案在窗口管理方面和可灵活新增功能的方面优于2号方案。在构建1号方案的过程中，发现在LRU淘汰上存在问题：
    + 如果用户正巧在看一个将要被淘汰的窗口，此刻打开一个新窗口，将会覆盖此刻正在看的窗口
    + 如果用户因为某些原因打开了很多非热点窗口，那么热点窗口可能会被淘汰，导致命中率降低
    通过研究lru和问题出现的本质，发现其实都出在lru进行窗口淘汰的时候一些操作会使得缓存收到污染。所以优化了一下原有的lru算法，通过在lru外部新增一层访问历史队列，只有当某窗口被打开的次数达到目标值则加入lru的缓存列表，同时构建一个备份列表标记窗口是否活跃，如果活跃则不进行淘汰操作，转而标记为即将淘汰，当窗口失活后立刻淘汰该窗口。通过以上方法自己整理了一个windowsManager的窗口管理类并发布在内网中，并且在团队中解决此问题并推进项目。
### 2. 拓扑图树状结构
新的需求中要求使用拓扑图来展示节点信息和状态，在选择如何使用时有几个方案：
+ 使用echarts自带的树状结构来展示节点父子关系
+ 使用antv的树结构来展示
+ 自己构建一个树结构来展示
在这个需求中，我们需要节点信息可以根据我们的需要进行替换，及节点内容可以自定义并且可以支持各种内容的填充，其次最好可以实现节点可拖动。1方案中他可支持配置的方式限制较多而且可能会不满足一些需求，2方案中除了与1方案存在类似的问题，引入一个尚未使用的库也没有必要（虽然可以按需引入，但是为了这么一个功能使用新的库总觉得没有必要），所以只剩下自己新写一个组件的方案了，这个方案其实不难，实现一个树状结构不是问题，主要是树状结构内的页面可供我们自定义，用到vue中的插槽功能，即提前占了坑位，通过插槽的内容去填充坑位，这样坑位内的内容就可以被我们自定义了，然后在外部实现外部div的拖动操作，监听mousedown，mousemove，mouseup，监听到鼠标按下后，在此刻在mousemove里的方法可以执行，使用clientX和clientY来标识鼠标的移动坐标，使用offsetTop和offsetLeft来标识元素所在的位置，然后通过鼠标实时的位置信息-初始位置+元素位置，就可以让元素跟随鼠标进行移动了，然后在mousemove中监听mouseup并清除down和move的事件，即可以在移动过程中松开鼠标的同时，也停止元素跟随，然后早mousedown中监听mouseup并清除down和move的事件，这样可以保证点击但是未发生移动操作然后松开鼠标后，停止元素跟随。然后在使用的过程中，后端要求不使用树状结构来进行接口数据传值，于是使用扁平数据传值，然后前端通过读取id和parentId来将扁平结构转成树状结构，主要是构建了一个递归，找到parentId的节点，然后将对应的子节点加入父节点的children中，此刻递归调用自己的方法传入此节点的id当作下一个的parentId，递归出口就是再也找不到子节点了。完成功能后发布了一个组件包，并且在项目中应用了。
### 3. 图表性能优化
在首页中，因为存在9个图表，当数据量不大时，展示问题不大，但是如果数据多了之后，页面加载就会很卡顿，并且在长期开启后会出现内存泄漏页面奔溃，为了解决这个问题想了几个对应的解决方法：
+ 只看趋势的图表，采用echarts自有的Largest-Triangle-Three-Bucket 算法，可以最大程度保证采样后线条的趋势，形状和极值,配置上`sampling: "lttb"`后即可大大减少需要渲染的点
+ 借助webworker将数据请求的接口和数据处理的内容放在单独的一个线程内，并且分片获取数据，获取一次数据后直接吐出数据来进行渲染，可以让页面的流畅度提升很多
+ 在某些图表中的数据点是可以点击的，这些事件在下次重新渲染时及时清除，同时因为echarts对象一旦生成不会有变动，所以echarts对象不需要放在vue的响应式数据中，同时在生成options时许多数据的临时变量应该及时手动制空，这样可以减少因为多次自动刷新页面而出现的内存泄漏问题